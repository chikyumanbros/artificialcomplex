document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('canvas');
    // 幅と高さの比率を1:1に近づける（正方形のグリッドになるように）
    const width = 90;
    const height = 50;
    
    // ASCII文字のセット - 単純に密度を表現
    const asciiChars = '▓▒░+*·';
    
    // 最小限のシミュレーションパラメータ
    const initialEntityCount = 1;
    const maxEntities = 400;
    const baseEnergyDecay = 0.0005;  // エネルギー消費を抑制
    const DIVISION_ENERGY_THRESHOLD = 0.6;  // 分裂に必要なエネルギー閾値を0.8から0.6に減少
    const DIVISION_PROBABILITY = 0.1;      // 分裂確率を0.05から0.1に増加
    const DIVISION_COOLDOWN = 50;          // 分裂後のクールダウン期間を150から50に短縮
    
    // 時間変数
    let time = 0;
    
    // UI関連の変数
    let frameCount = 0;
    let paused = false;
    let showStats = false;
    let selectedEntity = null;
    let simulationSpeed = 1.0;
    
    // グローバル変数としてシステム全体のエネルギー総量を定義
    const TOTAL_SYSTEM_ENERGY = 2000;  // 任意の単位
    
    // Entityクラス - 抽象的な「実体」として再定義
    class Entity {
        // 静的IDカウンタ
        static nextId = 0;
        
        constructor(x, y, attributes = null) {
            // 一意のID
            this.id = Entity.nextId++;
            
            // 位置
            this.position = {
                x: x !== undefined ? x : Math.random() * width,
                y: y !== undefined ? y : Math.random() * height
            };
            
            // 速度
            this.velocity = {
                x: (Math.random() - 0.5) * 0.5,
                y: (Math.random() - 0.5) * 0.5
            };
            
            // 基本属性 - より抽象的なパラメータへ
            this.attributes = attributes || {
                // センサー感度 - 環境変化の検知能力
                sensorSensitivity: Math.random(),
                
                // エネルギー変換率 - 環境からエネルギーを得る効率
                energyConversion: Math.random(),
                
                // 運動効率 - 動くためのエネルギー効率
                movementEfficiency: Math.random(),
                
                // 反応速度 - 環境変化への対応速度
                responseRate: Math.random(),
                
                // 構造強度 - 物理的耐久性
                structuralIntegrity: Math.random()
            };
            
            // エネルギーと状態
            this.energy = 0.5 + Math.random() * 0.5;
            this.age = 0;
            this.isActive = true;
            this.density = 0.1 + Math.random() * 0.9; // 密度（表示サイズに影響）
            
            // 分裂関連の変数を初期化
            this.lastDivisionTime = null;
            this.divisionCooldown = 0;
            
            // 新しい情報交換関連の属性を追加
            this.signals = {
                presence: 0.5 + Math.random() * 0.5,  // 存在のシグナル強度
                boundary: 0.3 + Math.random() * 0.7   // 境界のシグナル強度
            };
            
            // 内部状態の保存（記憶）
            this.memory = {
                signalGradients: {},     // 各シグナルタイプの勾配
                lastPosition: {...this.position},  // 前回の位置
                signalHistory: {},        // シグナル履歴
                sensedEntities: []        // 検知した実体を記憶
            };
            
            // Entityクラスに追加する属性
            this.wonder = {
                curiosity: Math.random(),  // 好奇心の強さ
                explorationMap: {},        // 探索済みの領域を記録
                noveltyThreshold: 0.3 + Math.random() * 0.4,  // 新奇性の閾値
                lastNoveltyEncounter: 0    // 最後に新奇なものに遭遇した時間
            };
            
            // シンプル化された遺伝子構造
            this.genome = {
                // メタデータ
                meta: {
                    version: 1,                  // 遺伝子構造のバージョン
                    creationTime: time,         // 作成時刻
                    parentId: null,             // 親のID（分裂/複製時に設定）
                    generation: 0               // 世代数
                },
                // 単一のシンプルなビット配列
                sequence: this.generateGenome(), // 遺伝子配列を生成
                // 遺伝子から発現した属性値
                expression: null                // デコード後の属性値
            };
            
            // 記憶容量を計算（遺伝子コードの長さに依存）
            this.memoryCapacity = this.calculateMemoryCapacity();
            
            // Entityクラスに追加する新しい属性
            this.communication = {
                // 発信関連
                transmission: {
                    energy: 0,          // 発信するエネルギー量
                    geneSequence: null, // 発信する遺伝子配列
                    signals: {          // 各種シグナル
                        presence: 0,    // 存在シグナル
                        boundary: 0,    // 境界シグナル
                        geneShare: 0    // 遺伝子共有意思
                    }
                },
                
                // 受信関連
                reception: {
                    buffer: [],        // 受信バッファ
                    threshold: 0.3,    // 受信閾値
                    filters: {         // 受信フィルター
                        energy: true,
                        genes: true,
                        signals: true
                    }
                },
                
                // メモリ関連
                memory: {
                    geneArchive: [],   // 受信した遺伝子のアーカイブ
                    interactions: [],   // 相互作用履歴
                    successRate: {}    // 交換成功率の記録
                },
                
                // ブロックリスト
                blocking: {
                    // ブロックリスト
                    blockedEntities: new Map(),  // key: entityId, value: {reason: string, timestamp: number}
                    
                    // ブロック条件
                    conditions: {
                        // エネルギー搾取検知
                        energyTheft: {
                            threshold: 0.3,        // エネルギー搾取の閾値
                            duration: 200          // ブロック継続時間
                        },
                        
                        // 有害な遺伝子検知
                        harmfulGenes: {
                            threshold: -0.2,       // 有害度の閾値
                            duration: 300          // ブロック継続時間
                        },
                        
                        // スパムシグナル検知
                        signalSpam: {
                            threshold: 10,         // 単位時間あたりの最大シグナル数
                            duration: 100          // ブロック継続時間
                        }
                    },
                    
                    // 免疫記憶
                    immunity: {
                        patterns: new Map(),      // 有害パターンの記憶
                        threshold: 0.7            // 免疫反応の閾値
                    }
                }
            };
        }
        
        // 既存のinteractメソッドを維持しながら、情報交換の概念を追加
        interact(entities, environment) {
            let forces = { x: 0, y: 0 };
            
            // 他の実体を感知
            this.senseEntities(entities);
            
            // boidモデルによる力を計算
            const boidForces = this.calculateBoidForces();
            forces.x += boidForces.x;
            forces.y += boidForces.y;
            
            // エネルギー交換を実行
            this.exchangeEnergy(entities);
            
            // 他の実体への反応
            const entityForces = this.reactToEntities();
            forces.x += entityForces.x;
            forces.y += entityForces.y;
            
            // 境界処理
            this.enforceBoundaries(forces);
            
            return forces;
        }
        
        // boidモデルの力を計算
        calculateBoidForces() {
            if (!this.memory.sensedEntities || this.memory.sensedEntities.length === 0) {
                return { x: 0, y: 0 };
            }

            const forces = { x: 0, y: 0 };
            const cohesion = { x: 0, y: 0 };
            const alignment = { x: 0, y: 0 };
            const separation = { x: 0, y: 0 };
            
            let totalWeight = 0;
            let separationCount = 0;

            for (const sensed of this.memory.sensedEntities) {
                const other = sensed.entity;
                const similarity = this.calculateGeneticSimilarity(other);
                
                // 遺伝的類似度が高いほど強く影響
                const weight = Math.pow(similarity, 2);
                
                // 結合（中心に向かう力）
                cohesion.x += other.position.x * weight;
                cohesion.y += other.position.y * weight;
                
                // 整列（同じ方向に向かう力）
                alignment.x += other.velocity.x * weight;
                alignment.y += other.velocity.y * weight;
                
                // 分離（近すぎる個体から離れる力）
                if (sensed.distance < 5) {
                    const repulsionStrength = (5 - sensed.distance) / 5;
                    separation.x += sensed.direction.x * repulsionStrength;
                    separation.y += sensed.direction.y * repulsionStrength;
                    separationCount++;
                }
                
                totalWeight += weight;
            }

            // 結合力の正規化と適用
            if (totalWeight > 0) {
                const cohesionStrength = 0.01;
                forces.x += (cohesion.x / totalWeight - this.position.x) * cohesionStrength;
                forces.y += (cohesion.y / totalWeight - this.position.y) * cohesionStrength;
                
                // 整列力の正規化と適用
                const alignmentStrength = 0.05;
                forces.x += (alignment.x / totalWeight) * alignmentStrength;
                forces.y += (alignment.y / totalWeight) * alignmentStrength;
            }

            // 分離力の適用
            if (separationCount > 0) {
                const separationStrength = 0.1;
                forces.x -= separation.x * separationStrength / separationCount;
                forces.y -= separation.y * separationStrength / separationCount;
            }

            return forces;
        }
        
        // 新しいシグナル受信メソッド
        receiveSignal(sourcePosition, signalType, intensity) {
            const dx = sourcePosition.x - this.position.x;
            const dy = sourcePosition.y - this.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // 距離による減衰
            const attenuatedIntensity = intensity / (1 + distance * distance);
            
            // シグナル履歴の初期化
            if (!this.memory.signalHistory[signalType]) {
                this.memory.signalHistory[signalType] = [];
            }
            
            // シグナルと方向の記録
            this.memory.signalHistory[signalType].push({
                intensity: attenuatedIntensity,
                direction: {
                    x: dx / Math.max(0.001, distance),
                    y: dy / Math.max(0.001, distance)
                },
                time: time
            });
            
            // 古いシグナルの削除（メモリ制限）
            const memoryDuration = 10; // 記憶する時間
            this.memory.signalHistory[signalType] = 
                this.memory.signalHistory[signalType].filter(s => time - s.time < memoryDuration);
            
            // シグナル勾配の更新
            this.updateSignalGradient(signalType);
        }
        
        // シグナル勾配の更新
        updateSignalGradient(signalType) {
            if (!this.memory.signalHistory[signalType] || 
                this.memory.signalHistory[signalType].length === 0) {
                return;
            }
            
            let gradX = 0, gradY = 0, totalIntensity = 0;
            
            for (const signal of this.memory.signalHistory[signalType]) {
                gradX += signal.direction.x * signal.intensity;
                gradY += signal.direction.y * signal.intensity;
                totalIntensity += signal.intensity;
            }
            
            // 勾配の正規化
            this.memory.signalGradients[signalType] = {
                x: totalIntensity > 0 ? gradX / totalIntensity : 0,
                y: totalIntensity > 0 ? gradY / totalIntensity : 0,
                intensity: totalIntensity / this.memory.signalHistory[signalType].length
            };
        }
        
        // シグナル勾配に基づく力の計算
        processSignalGradients() {
            const forces = { x: 0, y: 0 };
            
            // 存在シグナルへの反応（混雑回避）
            if (this.memory.signalGradients.presence) {
                const grad = this.memory.signalGradients.presence;
                const repulsionStrength = 0.01 * this.attributes.responseRate;
                
                forces.x -= grad.x * repulsionStrength * grad.intensity;
                forces.y -= grad.y * repulsionStrength * grad.intensity;
            }
            
            // 境界シグナルへの反応
            if (this.memory.signalGradients.boundary) {
                const grad = this.memory.signalGradients.boundary;
                const boundaryStrength = 0.02 * this.signals.boundary;
                
                // 強い境界からは離れる
                if (grad.intensity > this.signals.boundary) {
                    forces.x -= grad.x * boundaryStrength;
                    forces.y -= grad.y * boundaryStrength;
                }
            }
            
            return forces;
        }
        
        // 揺らぎの追加
        addBrownianMotion() {
            // エネルギーレベルと相関する揺らぎの強さ
            const brownianStrength = 0.01 * (1 - this.energy * 0.5);
            
            return {
                x: (Math.random() - 0.5) * brownianStrength,
                y: (Math.random() - 0.5) * brownianStrength
            };
        }
        
        // エネルギー処理のメソッドを追加
        processEnergy(environment, subjectiveTimeScale = 1.0) {
            // 基本的なエネルギー消費
            const baseCost = baseEnergyDecay * (1 - this.attributes.movementEfficiency * 0.5) * subjectiveTimeScale;
            this.energy -= baseCost;
            
            // 消費したエネルギーを環境に戻す（熱として）
            environment.returnEnergyAt(this.position, baseCost);
            
            // シグナル処理によるエネルギー消費を最小化
            const signalHistorySize = Object.values(this.memory.signalHistory).reduce(
                (sum, signals) => sum + signals.length, 0
            );
            const signalProcessingCost = 0.00005 * signalHistorySize * subjectiveTimeScale;
            
            this.energy -= signalProcessingCost;
            environment.returnEnergyAt(this.position, signalProcessingCost);
            
            // 環境からのエネルギー獲得
            const maxExtractableEnergy = 0.02 * this.attributes.energyConversion * subjectiveTimeScale;
            const gainedEnergy = environment.getEnergyAt(this.position, time, maxExtractableEnergy);
            this.energy += gainedEnergy;
            
            // エネルギー上限
            this.energy = Math.min(this.energy, 1.0);
        }
        
        // 既存のupdateメソッドに統合
        update(entities, environment, subjectiveTimeScale = 1.0) {
            if (!this.isActive) return;
            
            // 年齢の更新
            this.age += subjectiveTimeScale;
            
            // エネルギー処理
            this.processEnergy(environment, subjectiveTimeScale);
            
            // 相互作用による力
            const forces = this.interact(entities, environment);
            
            // ワンダーモジュールによる力を追加
            const wonderForces = this.processWonder(environment);
            
            // ブラウン運動による揺らぎ
            const brownian = this.addBrownianMotion();
            
            // 速度の更新（物理的力＋情報的力＋揺らぎ）
            this.velocity.x += (forces.x + wonderForces.x) * subjectiveTimeScale + brownian.x;
            this.velocity.y += (forces.y + wonderForces.y) * subjectiveTimeScale + brownian.y;
            
            // 速度の減衰
            const friction = Math.pow(0.95, subjectiveTimeScale);
            this.velocity.x *= friction;
            this.velocity.y *= friction;
            
            // 位置の更新
            this.position.x += this.velocity.x * subjectiveTimeScale;
            this.position.y += this.velocity.y * subjectiveTimeScale;
            
            // シグナル強度の更新
            this.signals.presence = 0.3 + this.energy * 0.7;  // エネルギーが高いほど存在感が強い
            this.signals.boundary = Math.min(1.0, 0.2 + this.density * 0.8);  // 密度が高いほど境界が強い
            
            // 繁殖判定 - シンプル化された遺伝子構造を使用
            // 遺伝子表現がなければ解釈する
            if (!this.genome.expression) {
                this.interpretGenome();
            }
            
            // 分裂クールダウンのチェック
            const cooldownPassed = this.divisionCooldown <= 0;
            
            // 分裂閾値と確率のチェック
            const divisionThreshold = this.genome.expression?.divisionThreshold || DIVISION_ENERGY_THRESHOLD;
            
            if (this.energy > divisionThreshold && 
                cooldownPassed && 
                Math.random() < DIVISION_PROBABILITY * subjectiveTimeScale) {
                this.divide(entities);
            }
            
            // 活性状態の更新
            if (this.energy <= 0 || this.age > 1000) {
                // 死亡時に残りのエネルギーを環境に戻す
                environment.returnEnergyAt(this.position, this.energy);
                this.energy = 0;
                this.isActive = false;
            }
            
            // 前回位置を記録
            this.memory.lastPosition = {...this.position};
            
            // 定期的に記憶の整理を行う（100フレームごと）
            if (Math.floor(this.age) % 100 === 0) {
                this.pruneMemory();
            }
        }
        
        // 境界処理のメソッドを追加
        enforceBoundaries(forces) {
            const margin = 5;
            const boundaryForce = 0.05;
            
            // X軸の境界
            if (this.position.x < margin) {
                forces.x += boundaryForce;
            } else if (this.position.x > width - margin) {
                forces.x -= boundaryForce;
            }
            
            // Y軸の境界
            if (this.position.y < margin) {
                forces.y += boundaryForce;
            } else if (this.position.y > height - margin) {
                forces.y -= boundaryForce;
            }
        }
        
        // 分裂（複製）メソッド
        divide(entities) {
            if (entities.length >= maxEntities) return;
            
            // 遺伝子から解釈された値がなければ、解釈を実行
            if (!this.genome.expression) {
                this.interpretGenome();
            }
            
            // 分裂に必要なエネルギーをチェック
            const divisionThreshold = this.genome.expression?.divisionThreshold || DIVISION_ENERGY_THRESHOLD;
            if (this.energy < divisionThreshold) return;
            
            // クールダウンをチェック
            if (this.divisionCooldown > 0) return;
            
            // 分裂確率をチェック（シンプルなランダム確率）
            if (Math.random() > DIVISION_PROBABILITY) return;
            
            // 分裂時のエネルギー分配
            const energyRatio = this.genome.expression?.divisionEnergyRatio || 0.5;
            const splitEnergy = this.energy * energyRatio;
            this.energy = this.energy * (1 - energyRatio);
            
            // 分裂後のクールダウンを設定
            this.lastDivisionTime = time;
            this.divisionCooldown = DIVISION_COOLDOWN;
            
            // 新しいエンティティを作成
            const child = new Entity(
                this.position.x + (Math.random() * 10 - 5),
                this.position.y + (Math.random() * 10 - 5)
            );
            
            // 子エンティティの遺伝子を設定（シンプルな構造）
            child.genome = {
                meta: {
                    version: this.genome.meta.version,
                    creationTime: time,
                    parentId: this.id,
                    generation: this.genome.meta.generation + 1
                },
                sequence: this.mutateGenome([...this.genome.sequence]),
                expression: null
            };
            
            // 遺伝子を解釈して属性に適用
            child.interpretGenome();
            
            // 子エンティティの初期エネルギーを設定
            child.energy = splitEnergy;
            
            // シグナル値も属性から生成
            child.signals = {
                presence: 0.3 + child.attributes.responseRate * 0.7,
                boundary: 0.2 + child.attributes.structuralIntegrity * 0.8
            };
            
            // 子エンティティを追加
            entities.push(child);
            
            return child;
        }
        
        // 新しいメソッド: ワンダーモジュールの処理
        processWonder(environment) {
            const forces = { x: 0, y: 0, z: 0 };
            
            // 1. 未探索領域への引力
            const currentCell = `${Math.floor(this.position.x)},${Math.floor(this.position.y)}`;
            this.wonder.explorationMap[currentCell] = (this.wonder.explorationMap[currentCell] || 0) + 1;
            
            // 周囲のセルの探索状況を確認
            const radius = 5;
            let leastExploredDir = { x: 0, y: 0, z: 0 };
            let minExplorationCount = Infinity;
            let equallyLeastExploredDirs = [];
            
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    const cell = `${Math.floor(this.position.x + dx)},${Math.floor(this.position.y + dy)}`;
                    const explorationCount = this.wonder.explorationMap[cell] || 0;
                    
                    if (explorationCount < minExplorationCount) {
                        minExplorationCount = explorationCount;
                        equallyLeastExploredDirs = [{ 
                            x: dx / Math.max(1, Math.abs(dx)) || 0, 
                            y: dy / Math.max(1, Math.abs(dy)) || 0,
                            z: 0
                        }];
                    } else if (explorationCount === minExplorationCount) {
                        // 同じ訪問回数の場合、候補に追加
                        equallyLeastExploredDirs.push({ 
                            x: dx / Math.max(1, Math.abs(dx)) || 0, 
                            y: dy / Math.max(1, Math.abs(dy)) || 0,
                            z: 0
                        });
                    }
                }
            }
            
            // 同じ訪問回数の候補からランダムに選択
            if (equallyLeastExploredDirs.length > 0) {
                const randomIndex = Math.floor(Math.random() * equallyLeastExploredDirs.length);
                leastExploredDir = equallyLeastExploredDirs[randomIndex];
            }
            
            // 未探索領域への引力を計算
            const explorationStrength = 0.02 * this.wonder.curiosity;
            forces.x += leastExploredDir.x * explorationStrength;
            forces.y += leastExploredDir.y * explorationStrength;
            
            // 2. 環境の変化への反応
            // 環境エネルギーの勾配を検出し、変化が大きい方向に引き寄せられる
            const cellSize = 1;
            const energyHere = environment.getEnergyAt(this.position, time, 0);
            
            const directions = [
                {dx: cellSize, dy: 0, dz: 0},
                {dx: -cellSize, dy: 0, dz: 0},
                {dx: 0, dy: cellSize, dz: 0},
                {dx: 0, dy: -cellSize, dz: 0}
            ];
            
            let maxGradient = 0;
            let gradientDir = { x: 0, y: 0, z: 0 };
            
            for (const dir of directions) {
                const checkPos = {
                    x: this.position.x + dir.dx,
                    y: this.position.y + dir.dy,
                    z: this.position.z + dir.dz
                };
                
                const energyThere = environment.getEnergyAt(checkPos, time, 0);
                const gradient = Math.abs(energyThere - energyHere);
                
                if (gradient > maxGradient) {
                    maxGradient = gradient;
                    gradientDir = { x: dir.dx, y: dir.dy, z: dir.dz };
                }
            }
            
            // 変化が閾値を超えた場合、その方向に引き寄せられる
            if (maxGradient > this.wonder.noveltyThreshold) {
                const noveltyStrength = 0.03 * this.wonder.curiosity;
                forces.x += gradientDir.x * noveltyStrength;
                forces.y += gradientDir.y * noveltyStrength;
                this.wonder.lastNoveltyEncounter = time;
            }
            
            // 長時間新奇なものに遭遇していない場合、ランダム探索を強化
            const timeSinceNovelty = time - this.wonder.lastNoveltyEncounter;
            if (timeSinceNovelty > 50) {
                const randomExplorationStrength = 0.01 * Math.min(5, timeSinceNovelty / 10);
                forces.x += (Math.random() - 0.5) * randomExplorationStrength;
                forces.y += (Math.random() - 0.5) * randomExplorationStrength;
            }
            
            return forces;
        }
        
        // Entityクラスに追加するメソッド
        senseEntities(entities) {
            const sensedEntities = [];
            
            for (const other of entities) {
                if (other === this || !other.isActive) continue;
                
                // 距離の計算
                const dx = other.position.x - this.position.x;
                const dy = other.position.y - this.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // センサー感度に基づく検知範囲
                const detectionRange = 15 * this.attributes.sensorSensitivity;
                
                if (distance < detectionRange) {
                    // 他者のエネルギー情報を含めて記録
                    sensedEntities.push({
                        entity: other,
                        distance: distance,
                        direction: {
                            x: dx / Math.max(0.001, distance),
                            y: dy / Math.max(0.001, distance)
                        },
                        perceivedEnergy: other.energy * (1 - distance / detectionRange) // 距離による減衰
                    });
                }
            }
            
            // 検知した実体を記憶に保存
            this.memory.sensedEntities = sensedEntities;
            
            return sensedEntities;
        }
        
        // エネルギー交換メソッドの修正
        exchangeEnergy(entities) {
            if (!this.memory.sensedEntities || this.memory.sensedEntities.length === 0) return;
            
            // エネルギー交換の総量（この実体が交換できる最大量）
            const maxExchangeAmount = 0.05 * this.energy;
            
            // 各検知実体との交換を試みる
            for (const sensed of this.memory.sensedEntities) {
                const other = sensed.entity;
                
                // 遺伝的類似度を計算
                const similarity = this.calculateGeneticSimilarity(other);
                
                // エネルギー状態の差異
                const energyDiff = this.energy - other.energy;
                const efficiencyDiff = this.attributes.energyConversion - other.attributes.energyConversion;
                
                // 基本的な相互作用の強さ（-1から1の範囲）
                // 類似度が高いほど、エネルギー差に基づく自然な均衡化が起きやすい
                const baseInteraction = -Math.sign(energyDiff) * similarity;
                
                // 効率差による影響（効率の良い方が得をする傾向）
                const efficiencyEffect = Math.sign(efficiencyDiff) * Math.abs(efficiencyDiff) * (1 - similarity);
                
                // 最終的な交換方向の決定
                const exchangeDirection = baseInteraction + efficiencyEffect;
                
                // 距離による減衰
                const distanceFactor = 1 - sensed.distance / (15 * this.attributes.sensorSensitivity);
                
                // 実際の交換量を計算
                const exchangeAmount = maxExchangeAmount * exchangeDirection * distanceFactor;
                
                // 相互作用タイプの判定（事後的な分類）
                const interactionType = this.classifyInteraction(exchangeDirection, similarity, efficiencyDiff);
                
                // エネルギー交換の実行
                if (exchangeAmount > 0) {
                    const actualGain = Math.min(exchangeAmount, other.energy * 0.2);
                    this.energy += actualGain;
                    other.energy -= actualGain;
                    
                    // 相互作用の記憶
                    this.recordInteraction(interactionType, 'gain', other, actualGain, similarity);
                } else if (exchangeAmount < 0) {
                    const actualLoss = Math.min(-exchangeAmount, this.energy * 0.2);
                    this.energy -= actualLoss;
                    other.energy += actualLoss;
                    
                    // 相互作用の記憶
                    this.recordInteraction(interactionType, 'give', other, actualLoss, similarity);
                }
            }
        }
        
        // 相互作用の記録
        recordInteraction(type, direction, target, details) {
            this.communication.memory.interactions.push({
                type: type,
                direction: direction,
                target: target,
                details: details,
                timestamp: time,
                success: true
            });
            
            // 記憶容量を超えた場合に整理
            this.pruneMemory();
            
            // 成功率の更新
            const key = `${type}_${direction}`;
            if (!this.communication.memory.successRate[key]) {
                this.communication.memory.successRate[key] = {
                    success: 0,
                    total: 0
                };
            }
            
            this.communication.memory.successRate[key].total++;
            this.communication.memory.successRate[key].success++;
        }
        
        // 相互作用の事後的な分類（観察のため）
        classifyInteraction(exchangeDirection, similarity, efficiencyDiff) {
            // 交換の方向と強さから相互作用を分類
            const absExchange = Math.abs(exchangeDirection);
            
            if (absExchange < 0.1) {
                return 'neutral';  // ほとんど相互作用なし
            } else if (similarity > 0.6 && Math.sign(exchangeDirection) === -Math.sign(efficiencyDiff)) {
                return 'cooperation';  // 効率差を補完するような交換
            } else if (Math.sign(exchangeDirection) === Math.sign(efficiencyDiff)) {
                return 'parasitism';  // 効率差を拡大するような交換
            } else {
                return 'competition';  // その他の競争的な交換
            }
        }
        
        // 遺伝的類似度を計算
        calculateGeneticSimilarity(other) {
            if (!this.genome || !other.genome || !this.genome.core || !other.genome.core) return 0;
            
            const mySequence = this.genome.core.sequence;
            const otherSequence = other.genome.core.sequence;
            
            if (!mySequence || !otherSequence) return 0;
            
            // コア遺伝子の類似度（基本属性）
            const coreSimilarity = this.calculateSegmentSimilarity(
                mySequence,
                otherSequence
            );
            
            // 制御遺伝子の類似度
            const regulatorySimilarity = this.calculateRegulatorySimilarity(
                this.genome.regulatory,
                other.genome.regulatory
            );
            
            // 防御遺伝子の類似度
            const defenseSimilarity = this.calculateDefenseSimilarity(
                this.genome.defense,
                other.genome.defense
            );
            
            // 行動遺伝子の類似度
            const behaviorSimilarity = this.calculateBehaviorSimilarity(
                this.genome.behavior,
                other.genome.behavior
            );
            
            // 重み付けされた総合的な類似度
            return (
                coreSimilarity * 0.4 +          // コア遺伝子の重要性を高く
                regulatorySimilarity * 0.2 +    // 制御遺伝子
                defenseSimilarity * 0.2 +       // 防御遺伝子
                behaviorSimilarity * 0.2        // 行動遺伝子
            );
        }
        
        // 制御遺伝子の類似度を計算
        calculateRegulatorySimilarity(myRegulatory, otherRegulatory) {
            if (!myRegulatory || !otherRegulatory) return 0;
            
            const promoterSimilarity = this.calculateObjectSimilarity(
                myRegulatory.promoters,
                otherRegulatory.promoters
            );
            
            const inhibitorSimilarity = this.calculateObjectSimilarity(
                myRegulatory.inhibitors,
                otherRegulatory.inhibitors
            );
            
            const environmentalSimilarity = this.calculateObjectSimilarity(
                myRegulatory.environmentalResponses,
                otherRegulatory.environmentalResponses
            );
            
            const interactionSimilarity = this.calculateObjectSimilarity(
                myRegulatory.interactionControls,
                otherRegulatory.interactionControls
            );
            
            return (
                promoterSimilarity * 0.25 +
                inhibitorSimilarity * 0.25 +
                environmentalSimilarity * 0.25 +
                interactionSimilarity * 0.25
            );
        }
        
        // 防御遺伝子の類似度を計算
        calculateDefenseSimilarity(myDefense, otherDefense) {
            if (!myDefense || !otherDefense) return 0;
            
            const patternSimilarity = this.calculateObjectSimilarity(
                myDefense.patternRecognition,
                otherDefense.patternRecognition
            );
            
            const immuneSimilarity = this.calculateObjectSimilarity(
                myDefense.immuneResponse,
                otherDefense.immuneResponse
            );
            
            const repairSimilarity = this.calculateObjectSimilarity(
                myDefense.repair,
                otherDefense.repair
            );
            
            return (
                patternSimilarity * 0.4 +
                immuneSimilarity * 0.4 +
                repairSimilarity * 0.2
            );
        }
        
        // 行動遺伝子の類似度を計算
        calculateBehaviorSimilarity(myBehavior, otherBehavior) {
            if (!myBehavior || !otherBehavior) return 0;
            
            const movementSimilarity = this.calculateObjectSimilarity(
                myBehavior.movement,
                otherBehavior.movement
            );
            
            const socialSimilarity = this.calculateObjectSimilarity(
                myBehavior.social,
                otherBehavior.social
            );
            
            const explorationSimilarity = this.calculateObjectSimilarity(
                myBehavior.exploration,
                otherBehavior.exploration
            );
            
            return (
                movementSimilarity * 0.3 +
                socialSimilarity * 0.4 +
                explorationSimilarity * 0.3
            );
        }
        
        // オブジェクト内の配列の類似度を計算するヘルパーメソッド
        calculateObjectSimilarity(obj1, obj2) {
            if (!obj1 || !obj2) return 0;
            
            const keys = Object.keys(obj1);
            if (keys.length === 0) return 0;
            
            let totalSimilarity = 0;
            for (const key of keys) {
                if (obj1[key] && obj2[key]) {
                    totalSimilarity += this.calculateSegmentSimilarity(obj1[key], obj2[key]);
                }
            }
            
            return totalSimilarity / keys.length;
        }
        
        // 配列セグメント間の類似度を計算（既存のメソッド）
        calculateSegmentSimilarity(segment1, segment2) {
            if (!Array.isArray(segment1) || !Array.isArray(segment2)) return 0;
            
            const minLength = Math.min(segment1.length, segment2.length);
            let matchCount = 0;
            
            for (let i = 0; i < minLength; i++) {
                if (segment1[i] === segment2[i]) {
                    matchCount++;
                }
            }
            
            return matchCount / minLength;
        }
        
        // Entityクラスに追加するメソッド
        reactToEntities() {
            if (!this.memory.sensedEntities || this.memory.sensedEntities.length === 0) return { x: 0, y: 0 };
            
            const forces = { x: 0, y: 0 };
            
            // 過去の相互作用の記憶を分析
            const recentInteractions = (this.memory.interactions || [])
                .filter(i => time - i.time < 50); // 最近の相互作用のみ考慮
            
            // 各実体に対する態度を決定
            for (const sensed of this.memory.sensedEntities) {
                const other = sensed.entity;
                
                // この実体との過去の相互作用
                const interactionsWithThis = recentInteractions
                    .filter(i => i.target === other);
                
                // 過去の相互作用に基づく態度（-1: 回避、0: 中立、1: 接近）
                let attitude = 0;
                
                if (interactionsWithThis.length > 0) {
                    // 得たエネルギーと失ったエネルギーの合計
                    const gainedEnergy = interactionsWithThis
                        .filter(i => i.type === 'gain')
                        .reduce((sum, i) => sum + i.amount, 0);
                        
                    const lostEnergy = interactionsWithThis
                        .filter(i => i.type === 'give')
                        .reduce((sum, i) => sum + i.amount, 0);
                        
                    // 純利益に基づく態度
                    const netGain = gainedEnergy - lostEnergy;
                    attitude = netGain > 0 ? 1 : (netGain < 0 ? -1 : 0);
                } else {
                    // 過去の相互作用がない場合、エネルギーレベルに基づく判断
                    attitude = this.energy < 0.3 ? 1 : (sensed.perceivedEnergy > this.energy ? -1 : 0);
                }
                
                // 態度に基づく力の計算
                const forceMagnitude = 0.02 * this.attributes.responseRate;
                
                if (attitude > 0) {
                    // 接近（捕食または協力の可能性）
                    forces.x += sensed.direction.x * forceMagnitude;
                    forces.y += sensed.direction.y * forceMagnitude;
                } else if (attitude < 0) {
                    // 回避（危険または競争相手）
                    forces.x -= sensed.direction.x * forceMagnitude;
                    forces.y -= sensed.direction.y * forceMagnitude;
                }
            }
            
            return forces;
        }
        
        // バイナリ遺伝子を生成するメソッド
        generateRandomGenome() {
            const genomeLength = 120; // 各属性に24ビット割り当て（5属性 × 24ビット）
            const sequence = [];
            
            for (let i = 0; i < genomeLength; i++) {
                sequence.push(Math.random() < 0.5 ? 0 : 1);
            }
            
            return sequence;
        }
        
        // 属性をバイナリ遺伝子にエンコードするメソッド
        encodeAttributes(attributes) {
            const sequence = [];
            const attributeKeys = [
                'sensorSensitivity', 
                'energyConversion', 
                'movementEfficiency', 
                'responseRate', 
                'structuralIntegrity'
            ];
            
            // 各属性を24ビットのバイナリに変換
            for (const key of attributeKeys) {
                const value = attributes[key];
                const binaryValue = this.valueToBinary(value, 24);
                sequence.push(...binaryValue);
            }
            
            return sequence;
        }
        
        // 数値を指定ビット数のバイナリ配列に変換
        valueToBinary(value, bits) {
            const binaryArray = [];
            // 0-1の値を0-2^bits-1の整数に変換
            const intValue = Math.floor(value * ((1 << bits) - 1));
            
            for (let i = 0; i < bits; i++) {
                binaryArray.push((intValue >> i) & 1);
            }
            
            return binaryArray;
        }
        
        // バイナリ遺伝子を属性にデコードするメソッド
        decodeGenome(sequence) {
            const attributes = {};
            const attributeKeys = [
                'sensorSensitivity', 
                'energyConversion', 
                'movementEfficiency', 
                'responseRate', 
                'structuralIntegrity'
            ];
            
            // 各24ビットのセグメントを属性値にデコード
            for (let i = 0; i < attributeKeys.length; i++) {
                const start = i * 24;
                const segment = sequence.slice(start, start + 24);
                
                // 遺伝子が機能しているかチェック（例：特定のパターンが必要）
                const isFunctional = this.checkGeneFunctionality(segment);
                
                if (isFunctional) {
                    attributes[attributeKeys[i]] = this.binaryToValue(segment);
                } else {
                    // 機能していない場合は最小値を設定
                    attributes[attributeKeys[i]] = 0.01;
                }
            }
            
            return attributes;
        }
        
        // バイナリ配列を0-1の値に変換
        binaryToValue(binaryArray) {
            let intValue = 0;
            
            for (let i = 0; i < binaryArray.length; i++) {
                intValue |= binaryArray[i] << i;
            }
            
            // 整数値を0-1の範囲に正規化
            return intValue / ((1 << binaryArray.length) - 1);
        }
        
        // 遺伝子が機能しているかをチェック
        checkGeneFunctionality(segment) {
            // 例：開始コドンと終了コドンが正しいかチェック
            const startCodon = segment.slice(0, 3).join('');
            const endCodon = segment.slice(segment.length - 3).join('');
            
            // 開始コドンが"101"で終了コドンが"010"の場合に機能すると仮定
            return startCodon === "101" && endCodon === "010";
            
            // より複雑な条件も可能:
            // - 特定のパターンが必要
            // - 特定の位置のビットが特定の値である必要がある
            // - パリティチェックが成功する必要がある
        }
        
        // 遺伝子の変異を処理するメソッド
        mutateGenome(sequence) {
            const mutatedSequence = [...sequence];
            const genomeLength = sequence.length;
            
            // 1. 点変異（ビットフリップ）- 低確率で各ビットが反転
            for (let i = 0; i < genomeLength; i++) {
                if (Math.random() < 0.005) { // 0.5%の確率で変異
                    mutatedSequence[i] = 1 - mutatedSequence[i]; // 0→1, 1→0
                }
            }
            
            // 2. 挿入変異 - 低確率で新しいビットが挿入される
            if (Math.random() < 0.02 && genomeLength < 200) { // 2%の確率、最大長を制限
                const position = Math.floor(Math.random() * genomeLength);
                const newBit = Math.random() < 0.5 ? 0 : 1;
                mutatedSequence.splice(position, 0, newBit);
                // 長さを調整（最後のビットを削除）
                if (mutatedSequence.length > genomeLength) {
                    mutatedSequence.pop();
                }
            }
            
            // 3. 欠失変異 - 低確率でビットが削除される
            if (Math.random() < 0.02 && genomeLength > 60) { // 2%の確率、最小長を保証
                const position = Math.floor(Math.random() * genomeLength);
                mutatedSequence.splice(position, 1);
                // 長さを調整（末尾にランダムなビットを追加）
                if (mutatedSequence.length < genomeLength) {
                    mutatedSequence.push(Math.random() < 0.5 ? 0 : 1);
                }
            }
            
            // 4. 逆位変異 - 低確率で一部の配列が反転する
            if (Math.random() < 0.01) { // 1%の確率
                const length = Math.floor(Math.random() * 10) + 2; // 2-11ビットの長さ
                const start = Math.floor(Math.random() * (genomeLength - length));
                const segment = mutatedSequence.slice(start, start + length);
                segment.reverse();
                for (let i = 0; i < length; i++) {
                    mutatedSequence[start + i] = segment[i];
                }
            }
            
            // 5. 重複変異 - 低確率で一部の配列が複製される
            if (Math.random() < 0.01 && genomeLength < 180) { // 1%の確率、最大長を制限
                const length = Math.floor(Math.random() * 8) + 2; // 2-9ビットの長さ
                const start = Math.floor(Math.random() * (genomeLength - length));
                const segment = mutatedSequence.slice(start, start + length);
                const insertPosition = Math.floor(Math.random() * genomeLength);
                
                // 複製したセグメントを挿入
                mutatedSequence.splice(insertPosition, 0, ...segment);
                
                // 長さを調整（末尾から超過分を削除）
                if (mutatedSequence.length > genomeLength) {
                    mutatedSequence.splice(genomeLength, mutatedSequence.length - genomeLength);
                }
            }
            
            return mutatedSequence;
        }

        // エネルギー発信
        transmitEnergy(targetEntity, amount) {
            if (this.energy < amount) return false;
            
            this.communication.transmission.energy = amount;
            const success = targetEntity.receiveEnergy(this, amount);
            
            if (success) {
                this.energy -= amount;
                this.recordInteraction('energy', 'transmit', targetEntity, amount);
            }
            
            return success;
        }

        // 遺伝子情報の発信
        transmitGenes(targetEntity, geneType = 'full') {
            let geneSequence;
            
            switch(geneType) {
                case 'full':
                    geneSequence = this.genome.sequence;
                    break;
                case 'partial':
                    // ランダムな部分配列を選択
                    const start = Math.floor(Math.random() * this.genome.sequence.length / 2);
                    const length = Math.floor(Math.random() * (this.genome.sequence.length - start));
                    geneSequence = this.genome.sequence.slice(start, start + length);
                    break;
                case 'compressed':
                    geneSequence = this.compressGenes(this.genome.sequence);
                    break;
            }

            this.communication.transmission.geneSequence = geneSequence;
            const success = targetEntity.receiveGenes(this, geneSequence, geneType);
            
            if (success) {
                this.recordInteraction('genes', 'transmit', targetEntity, geneType);
            }
            
            return success;
        }

        // シグナルの発信
        transmitSignals() {
            const signals = {
                presence: 0.3 + this.energy * 0.7,
                boundary: Math.min(1.0, 0.2 + this.density * 0.8),
                geneShare: this.calculateGeneShareWillingness()
            };
            
            this.communication.transmission.signals = signals;
            return signals;
        }

        // 遺伝子共有意思の計算
        calculateGeneShareWillingness() {
            // エネルギー状態、年齢、過去の成功率などから計算
            const energyFactor = this.energy > 0.7 ? 0.8 : 0.2;
            const ageFactor = Math.min(1.0, this.age / 500);
            const successRate = this.getInteractionSuccessRate('genes');
            
            return (energyFactor + ageFactor + successRate) / 3;
        }

        // エネルギー受信
        receiveEnergy(sourceEntity, amount) {
            if (!this.communication.reception.filters.energy) return false;
            
            // 受入判断
            const willAccept = this.evaluateEnergyReception(sourceEntity, amount);
            
            if (willAccept) {
                this.energy += amount;
                this.recordInteraction('energy', 'receive', sourceEntity, amount);
                return true;
            }
            
            return false;
        }

        // 遺伝子情報の受信
        receiveGenes(sourceEntity, geneSequence, geneType) {
            if (!this.communication.reception.filters.genes) return false;
            
            // 受入判断
            const willAccept = this.evaluateGeneReception(sourceEntity, geneSequence);
            
            if (willAccept) {
                // 遺伝子の保存とポテンシャルな組み込み
                this.communication.memory.geneArchive.push({
                    source: sourceEntity,
                    sequence: geneSequence,
                    type: geneType,
                    timestamp: time,
                    potentialValue: this.evaluateGenePotential(geneSequence)
                });
                
                // 記憶容量を超えた場合に整理
                this.pruneMemory();
                
                this.recordInteraction('genes', 'receive', sourceEntity, geneType);
                
                // 一定確率で遺伝子の組み込みを試行
                if (Math.random() < this.calculateGeneIntegrationProbability()) {
                    this.integrateReceivedGenes();
                }
                
                return true;
            }
            
            return false;
        }

            // 受信した遺伝子の統合を試行
    integrateReceivedGenes() {
        const recentGenes = this.communication.memory.geneArchive
            .filter(g => time - g.timestamp < 100)
            .sort((a, b) => b.potentialValue - a.potentialValue);
        
        if (recentGenes.length === 0) return;
        
        const targetGene = recentGenes[0];
        const integrationSuccess = Math.random() < 
            (targetGene.potentialValue * this.attributes.sensorSensitivity);
        
        if (integrationSuccess) {
            // 遺伝子の部分的な組み込み
            const newSequence = this.integrateGeneSequence(
                this.genome.core.sequence,
                targetGene.sequence
            );
            
            // 新しい遺伝子の評価と適用
            const newAttributes = this.decodeGenome(newSequence);
            if (this.evaluateNewAttributes(newAttributes)) {
                this.genome.core.sequence = newSequence;
                this.attributes = newAttributes;
                
                // 記憶容量を更新
                this.memoryCapacity = this.calculateMemoryCapacity();
                
                // 記憶を整理
                this.pruneMemory();
            }
        }
    }

    // 遺伝子配列の統合
    integrateGeneSequence(currentSequence, newSequence) {
        // ランダムな統合ポイントの選択
        const integrationPoint = Math.floor(Math.random() * currentSequence.length);
        const integrationLength = Math.min(
            newSequence.length,
            currentSequence.length - integrationPoint
        );
        
        // 新しい配列の作成
        const resultSequence = [...currentSequence];
        for (let i = 0; i < integrationLength; i++) {
            if (Math.random() < 0.5) { // 50%の確率で各ビットを統合
                resultSequence[integrationPoint + i] = newSequence[i];
            }
        }
        
        return resultSequence;
    }

    // 遺伝子のポテンシャル評価
    evaluateGenePotential(sequence) {
        const attributes = this.decodeGenome(sequence);
        let potential = 0;
        
        // 各属性の改善度を評価
        for (const key in attributes) {
            const improvement = attributes[key] - this.attributes[key];
            potential += improvement > 0 ? improvement : 0;
        }
        
        return Math.min(1.0, potential / Object.keys(attributes).length);
    }

        // 遺伝子の新しい属性評価
        evaluateNewAttributes(newAttributes) {
            // 実装が必要
            return true; // 仮実装
        }

        // シグナルの距離減衰を計算
        calculateDistance(sourceEntity) {
            const dx = this.position.x - sourceEntity.position.x;
            const dy = this.position.y - sourceEntity.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance;
        }

        // シグナルの減衰を計算
        attenuateSignals(signals, distance) {
            const attenuatedSignals = {
                presence: signals.presence * (1 - distance / 15),
                boundary: signals.boundary * (1 - distance / 15),
                geneShare: signals.geneShare * (1 - distance / 15)
            };
            return attenuatedSignals;
        }

        // 遺伝子の統合確率を計算
        calculateGeneIntegrationProbability() {
            // 実装が必要
            return 0.5; // 仮実装
        }

        // 相互作用成功率の取得
        getInteractionSuccessRate(type) {
            const transmitKey = `${type}_transmit`;
            const receiveKey = `${type}_receive`;
            
            const transmitRate = this.communication.memory.successRate[transmitKey];
            const receiveRate = this.communication.memory.successRate[receiveKey];
            
            if (!transmitRate || !receiveRate) return 0;
            
            const totalSuccess = transmitRate.success + receiveRate.success;
            const totalAttempts = transmitRate.total + receiveRate.total;
            
            return totalAttempts > 0 ? totalSuccess / totalAttempts : 0;
        }

        // ブロック判定と管理のメソッド
        isBlocked(sourceEntity) {
            const blockInfo = this.communication.blocking.blockedEntities.get(sourceEntity.id);
            if (!blockInfo) return false;
            
            // ブロック期間が終了していれば解除
            if (time - blockInfo.timestamp > this.communication.blocking.conditions[blockInfo.reason].duration) {
                this.communication.blocking.blockedEntities.delete(sourceEntity.id);
                return false;
            }
            
            return true;
        }

        // エネルギー搾取の検知
        detectEnergyTheft(sourceEntity, amount) {
            const recentInteractions = this.communication.memory.interactions
                .filter(i => i.target === sourceEntity && i.type === 'energy' && 
                        time - i.timestamp < 100);
            
            let netEnergyLoss = 0;
            for (const interaction of recentInteractions) {
                if (interaction.direction === 'give') {
                    netEnergyLoss += interaction.details;
                } else {
                    netEnergyLoss -= interaction.details;
                }
            }
            
            // 搾取判定
            if (netEnergyLoss > this.communication.blocking.conditions.energyTheft.threshold) {
                this.blockEntity(sourceEntity, 'energyTheft');
                return true;
            }
            
            return false;
        }

        // 有害な遺伝子の検知
        detectHarmfulGenes(sourceEntity, geneSequence) {
            // 遺伝子の評価
            const potentialImpact = this.evaluateGenePotential(geneSequence);
            
            // 有害判定
            if (potentialImpact < this.communication.blocking.conditions.harmfulGenes.threshold) {
                // 有害パターンを記憶
                this.recordHarmfulPattern(geneSequence);
                this.blockEntity(sourceEntity, 'harmfulGenes');
                return true;
            }
            
            return false;
        }

        // シグナルスパムの検知
        detectSignalSpam(sourceEntity) {
            const recentSignals = this.communication.reception.buffer
                .filter(s => s.source === sourceEntity && 
                        time - s.timestamp < 50).length;
            
            if (recentSignals > this.communication.blocking.conditions.signalSpam.threshold) {
                this.blockEntity(sourceEntity, 'signalSpam');
                return true;
            }
            
            return false;
        }

        // 有害パターンの記録と免疫記憶
        recordHarmfulPattern(geneSequence) {
            const pattern = this.extractPattern(geneSequence);
            const currentCount = this.communication.blocking.immunity.patterns.get(pattern) || 0;
            this.communication.blocking.immunity.patterns.set(pattern, currentCount + 1);
        }

        // 遺伝子パターンの抽出（特徴的な部分配列の抽出）
        extractPattern(geneSequence) {
            // 単純化のため、最初の24ビットを特徴として使用
            return geneSequence.slice(0, 24).join('');
        }

        // エンティティのブロック
        blockEntity(entity, reason) {
            this.communication.blocking.blockedEntities.set(entity.id, {
                reason: reason,
                timestamp: time
            });
            
            // ブロックイベントの記録
            this.recordInteraction('block', reason, entity, null);
        }

        // 受信メソッドの修正（既存のreceiveEnergyメソッドを更新）
        receiveEnergy(sourceEntity, amount) {
            // ブロック確認
            if (this.isBlocked(sourceEntity)) return false;
            
            // エネルギー搾取の検知
            if (this.detectEnergyTheft(sourceEntity, amount)) return false;
            
            // 既存の処理を継続
            if (!this.communication.reception.filters.energy) return false;
            
            const willAccept = this.evaluateEnergyReception(sourceEntity, amount);
            if (willAccept) {
                this.energy += amount;
                this.recordInteraction('energy', 'receive', sourceEntity, amount);
                return true;
            }
            
            return false;
        }

        // 遺伝子受信の修正（既存のreceiveGenesメソッドを更新）
        receiveGenes(sourceEntity, geneSequence, geneType) {
            // ブロック確認
            if (this.isBlocked(sourceEntity)) return false;
            
            // 有害遺伝子の検知
            if (this.detectHarmfulGenes(sourceEntity, geneSequence)) return false;
            
            // 免疫チェック
            const pattern = this.extractPattern(geneSequence);
            const immunityCount = this.communication.blocking.immunity.patterns.get(pattern) || 0;
            if (immunityCount > this.communication.blocking.immunity.threshold) {
                this.blockEntity(sourceEntity, 'harmfulGenes');
                return false;
            }
            
            // 既存の処理を継続
            // ... 以下既存のコード ...
        }

        // シグナル受信の修正（既存のreceiveSignalsメソッドを更新）
        receiveSignals(sourceEntity, signals) {
            // ブロック確認
            if (this.isBlocked(sourceEntity)) return false;
            
            // スパム検知
            if (this.detectSignalSpam(sourceEntity)) return false;
            
            // 既存の処理を継続
            // ... 以下既存のコード ...
        }

        // 新しい遺伝子生成メソッド群
        generateCoreGenome() {
            const sequence = new Array(120);
            
            // 開始コドン
            sequence[0] = 1; sequence[1] = 0; sequence[2] = 1;
            
            // 属性エンコード領域（各属性24ビット）
            for (let i = 3; i < 117; i++) {
                // より多くの1を生成して明るい色になるようにする
                sequence[i] = Math.random() < 0.7 ? 1 : 0;
            }
            
            // 終了コドン
            sequence[117] = 0; sequence[118] = 1; sequence[119] = 0;
            
            return sequence;
        }

        // プロモーター配列の生成
        generatePromoters() {
            return {
                energy: this.generateRegulatorSequence(16),     // エネルギー代謝制御
                growth: this.generateRegulatorSequence(16),     // 成長制御
                repair: this.generateRegulatorSequence(16)      // 修復制御
            };
        }

        // 抑制配列の生成
        generateInhibitors() {
            return {
                energy: this.generateRegulatorSequence(16),     // エネルギー制限
                division: this.generateRegulatorSequence(16),   // 分裂制限
                mutation: this.generateRegulatorSequence(16)    // 変異制限
            };
        }

        // 環境応答配列の生成
        generateEnvironmentalResponses() {
            return {
                stress: this.generateRegulatorSequence(24),     // ストレス応答
                resources: this.generateRegulatorSequence(24),  // 資源応答
                density: this.generateRegulatorSequence(24)     // 密度応答
            };
        }

        // 相互作用制御配列の生成
        generateInteractionControls() {
            return {
                cooperation: this.generateRegulatorSequence(24),  // 協力行動制御
                competition: this.generateRegulatorSequence(24),  // 競争行動制御
                defense: this.generateRegulatorSequence(24)       // 防御行動制御
            };
        }

        // パターン認識配列の生成
        generatePatternRecognition() {
            return {
                self: this.generateRegulatorSequence(32),       // 自己認識
                harmful: this.generateRegulatorSequence(32),    // 有害パターン認識
                beneficial: this.generateRegulatorSequence(32)  // 有益パターン認識
            };
        }

        // 免疫応答配列の生成
        generateImmuneResponse() {
            return {
                memory: this.generateRegulatorSequence(32),     // 免疫記憶
                response: this.generateRegulatorSequence(32),   // 応答パターン
                adaptation: this.generateRegulatorSequence(32)  // 適応パターン
            };
        }

        // 修復配列の生成
        generateRepairSequence() {
            return {
                errorCorrection: this.generateRegulatorSequence(24),  // エラー訂正
                damage: this.generateRegulatorSequence(24),           // ダメージ修復
                mutation: this.generateRegulatorSequence(24)          // 変異修復
            };
        }

        // 行動パターン配列の生成
        generateMovementPattern() {
            return {
                base: this.generateRegulatorSequence(24),       // 基本移動
                avoidance: this.generateRegulatorSequence(24),  // 回避行動
                approach: this.generateRegulatorSequence(24)    // 接近行動
            };
        }

        // 社会的行動パターン配列の生成
        generateSocialPattern() {
            return {
                grouping: this.generateRegulatorSequence(24),   // 群れ行動
                sharing: this.generateRegulatorSequence(24),    // 共有行動
                signaling: this.generateRegulatorSequence(24)   // シグナル行動
            };
        }

        // 探索パターン配列の生成
        generateExplorationPattern() {
            return {
                curiosity: this.generateRegulatorSequence(24),  // 好奇心行動
                memory: this.generateRegulatorSequence(24),     // 記憶ベース探索
                risk: this.generateRegulatorSequence(24)        // リスク評価
            };
        }

        // 制御配列生成のヘルパーメソッド
        generateRegulatorSequence(length) {
            const sequence = new Array(length);
            
            // 制御配列の特徴的なパターンを生成
            for (let i = 0; i < length; i++) {
                // パターンベースの生成（単純なランダムよりも構造化）
                if (i % 4 === 0) {
                    sequence[i] = 1;  // 制御ポイントをマーク
                } else if (i % 4 === 1) {
                    sequence[i] = Math.random() < 0.7 ? 1 : 0;  // 高確率で1
                } else if (i % 4 === 2) {
                    sequence[i] = Math.random() < 0.3 ? 1 : 0;  // 低確率で1
                } else {
                    sequence[i] = Math.random() < 0.5 ? 1 : 0;  // ランダム
                }
            }
            
            return sequence;
        }

        // Entityクラスに追加する記憶伝達のメソッド

        // 記憶の発信
        transmitMemory(targetEntity, memoryType = 'experience') {
            // 発信する記憶データの準備
            let memoryData;
            
            switch(memoryType) {
                case 'experience':
                    memoryData = {
                        interactions: this.communication.memory.interactions.slice(-10), // 最近の10件
                        signalHistory: this.memory.signalHistory,
                        explorationMap: this.wonder.explorationMap
                    };
                    break;
                    
                case 'immune':
                    memoryData = {
                        harmfulPatterns: Array.from(this.communication.blocking.immunity.patterns),
                        blockedEntities: Array.from(this.communication.blocking.blockedEntities)
                    };
                    break;
                    
                case 'learning':
                    memoryData = {
                        successfulStrategies: this.communication.memory.successRate,
                        environmentalKnowledge: this.memory.signalGradients
                    };
                    break;
            }

            // 記憶データを通信システムに設定
            this.communication.transmission.memory = {
                type: memoryType,
                data: memoryData,
                timestamp: time,
                source: this
            };

            // 記憶の発信を試行
            const success = targetEntity.receiveMemory(this, memoryData, memoryType);
            
            if (success) {
                this.recordInteraction('memory', 'transmit', targetEntity, memoryType);
            }
            
            return success;
        }

        // 記憶の受信
        receiveMemory(sourceEntity, memoryData, memoryType) {
            // ブロックされたエンティティからの記憶は受け取らない
            if (this.isBlocked(sourceEntity)) return false;
            
            // 受信フィルターのチェック
            if (!this.communication.reception.filters.memory) return false;
            
            // 記憶の評価（有害な記憶や誤った情報を防ぐ）
            const memoryTrust = this.evaluateMemoryTrust(sourceEntity, memoryData);
            if (memoryTrust < this.communication.reception.threshold) return false;

            // 記憶の種類に応じた処理
            switch(memoryType) {
                case 'experience':
                    // 経験の統合
                    this.integrateExperience(memoryData);
                    break;
                    
                case 'immune':
                    // 免疫記憶の統合
                    this.integrateImmuneMemory(memoryData);
                    break;
                    
                case 'learning':
                    // 学習内容の統合
                    this.integrateLearning(memoryData);
                    break;
            }

            // 記憶の受信を記録
            this.recordInteraction('memory', 'receive', sourceEntity, memoryType);
            
            return true;
        }

        // 記憶の信頼性評価
        evaluateMemoryTrust(sourceEntity, memoryData) {
            let trustScore = 0;
            
            // 過去の相互作用履歴からの信頼度
            const pastInteractions = this.communication.memory.interactions
                .filter(i => i.target === sourceEntity);
            
            if (pastInteractions.length > 0) {
                const successfulInteractions = pastInteractions
                    .filter(i => i.success).length;
                trustScore += successfulInteractions / pastInteractions.length;
            }
            
            // 遺伝的類似度による信頼度
            const geneticSimilarity = this.calculateGeneticSimilarity(sourceEntity);
            trustScore += geneticSimilarity * 0.3;
            
            // データの一貫性チェック
            const consistencyScore = this.checkMemoryConsistency(memoryData);
            trustScore += consistencyScore * 0.3;
            
            return trustScore / 1.6; // 0-1の範囲に正規化
        }

        // 経験の統合
        integrateExperience(memoryData) {
            // 相互作用履歴の統合
            for (const interaction of memoryData.interactions) {
                if (!this.communication.memory.interactions.some(
                    i => i.timestamp === interaction.timestamp
                )) {
                    this.communication.memory.interactions.push({
                        ...interaction,
                        isInherited: true
                    });
                }
            }
            
            // 探索マップの統合
            for (const [cell, value] of Object.entries(memoryData.explorationMap)) {
                if (!this.wonder.explorationMap[cell]) {
                    this.wonder.explorationMap[cell] = value * 0.8; // 間接的な経験は割引
                }
            }
        }

        // 免疫記憶の統合
        integrateImmuneMemory(memoryData) {
            // 有害パターンの統合
            for (const [pattern, count] of memoryData.harmfulPatterns) {
                const currentCount = this.communication.blocking.immunity.patterns.get(pattern) || 0;
                this.communication.blocking.immunity.patterns.set(
                    pattern,
                    Math.max(currentCount, count * 0.7) // 間接的な経験は割引
                );
            }
        }

        // 学習内容の統合
        integrateLearning(memoryData) {
            // 成功率の統合
            for (const [key, rate] of Object.entries(memoryData.successfulStrategies)) {
                if (!this.communication.memory.successRate[key]) {
                    this.communication.memory.successRate[key] = {
                        success: rate.success * 0.7, // 間接的な経験は割引
                        total: rate.total
                    };
                }
            }
            
            // 環境知識の統合
            for (const [type, gradient] of Object.entries(memoryData.environmentalKnowledge)) {
                if (!this.memory.signalGradients[type]) {
                    this.memory.signalGradients[type] = {
                        ...gradient,
                        intensity: gradient.intensity * 0.8 // 間接的な経験は割引
                    };
                }
            }
        }

        // 記憶容量を計算するメソッドを追加
        calculateMemoryCapacity() {
            // コア遺伝子の長さを基準に記憶容量を計算
            const genomeLength = this.genome && this.genome.sequence ? this.genome.sequence.length : 128;
            
            // 基本容量（遺伝子アーカイブの最大数）
            const baseGeneArchiveCapacity = Math.floor(genomeLength / 10);
            
            // 基本容量（相互作用履歴の最大数）
            const baseInteractionCapacity = Math.floor(genomeLength / 6);
            
            return {
                geneArchive: Math.max(5, baseGeneArchiveCapacity), // 最低5件は保存
                interactions: Math.max(10, baseInteractionCapacity) // 最低10件は保存
            };
        }

        // 記憶を整理するメソッド（容量を超えた場合に古いデータを削除）
        pruneMemory() {
            // 遺伝子アーカイブの整理
            if (this.communication.memory.geneArchive.length > this.memoryCapacity.geneArchive) {
                // タイムスタンプでソートして古いものから削除
                this.communication.memory.geneArchive.sort((a, b) => a.timestamp - b.timestamp);
                
                // 容量を超えた分を削除
                this.communication.memory.geneArchive = this.communication.memory.geneArchive.slice(
                    this.communication.memory.geneArchive.length - this.memoryCapacity.geneArchive
                );
            }
            
            // 相互作用履歴の整理
            if (this.communication.memory.interactions.length > this.memoryCapacity.interactions) {
                // タイムスタンプでソートして古いものから削除
                this.communication.memory.interactions.sort((a, b) => a.timestamp - b.timestamp);
                
                // 容量を超えた分を削除
                this.communication.memory.interactions = this.communication.memory.interactions.slice(
                    this.communication.memory.interactions.length - this.memoryCapacity.interactions
                );
            }
        }

        // 繁殖戦略パターンの生成メソッドを追加
        generateReproductionPattern() {
            return {
                threshold: 0.3 + Math.random() * 0.5,  // 分裂閾値（0.3～0.8）
                probability: 0.01 + Math.random() * 0.19, // 分裂確率（0.01～0.2）
                energyRatio: 0.3 + Math.random() * 0.4,  // 子へのエネルギー分配率（0.3～0.7）
                cooldown: 30 + Math.floor(Math.random() * 120) // 分裂後のクールダウン（30～150）
            };
        }

        // 繁殖戦略の変異処理
        mutateReproductionPattern(pattern) {
            const mutated = {...pattern};
            
            // 各パラメータにわずかな変異を加える
            if (Math.random() < 0.1) {  // 10%の確率で変異
                mutated.threshold += (Math.random() - 0.5) * 0.2;  // ±0.1の範囲で変異
                mutated.threshold = Math.max(0.2, Math.min(0.9, mutated.threshold));  // 範囲を制約
            }
            
            if (Math.random() < 0.1) {
                mutated.probability += (Math.random() - 0.5) * 0.1;  // ±0.05の範囲で変異
                mutated.probability = Math.max(0.01, Math.min(0.3, mutated.probability));
            }
            
            if (Math.random() < 0.1) {
                mutated.energyRatio += (Math.random() - 0.5) * 0.2;  // ±0.1の範囲で変異
                mutated.energyRatio = Math.max(0.2, Math.min(0.8, mutated.energyRatio));
            }
            
            if (Math.random() < 0.1) {
                mutated.cooldown += Math.floor((Math.random() - 0.5) * 60);  // ±30の範囲で変異
                mutated.cooldown = Math.max(20, Math.min(200, mutated.cooldown));
            }
            
            return mutated;
        }

        // 以下の新しいシンプルな遺伝子メソッドを追加
        // シンプルな遺伝子配列の生成
        generateGenome() {
            const genomeLength = 128; // 最適なビット長（2の累乗で効率的）
            const sequence = new Array(genomeLength);
            
            // ランダムなビット配列を生成
            for (let i = 0; i < genomeLength; i++) {
                sequence[i] = Math.random() < 0.5 ? 0 : 1;
            }
            
            return sequence;
        }
        
        // シンプルな遺伝子の解釈メソッド
        interpretGenome() {
            if (!this.genome || !this.genome.sequence) return;
            
            const sequence = this.genome.sequence;
            const attributes = {};
            
            // 基本属性の解釈（遺伝子の異なる部分から値を抽出）
            attributes.sensorSensitivity = this.interpretGenomeSegment(sequence, 0, 24);
            attributes.energyConversion = this.interpretGenomeSegment(sequence, 24, 48);
            attributes.movementEfficiency = this.interpretGenomeSegment(sequence, 48, 72);
            attributes.responseRate = this.interpretGenomeSegment(sequence, 72, 96);
            attributes.structuralIntegrity = this.interpretGenomeSegment(sequence, 96, 120);
            
            // 追加のパラメータを解釈（もしあれば）
            if (sequence.length >= 128) {
                // 分裂閾値 (0.3～0.8の範囲)
                const divisionThresholdRaw = this.interpretGenomeSegment(sequence, 120, 124);
                attributes.divisionThreshold = 0.3 + (divisionThresholdRaw * 0.5);
                
                // 分裂エネルギー比率 (0.3～0.7の範囲)
                const energyRatioRaw = this.interpretGenomeSegment(sequence, 124, 128);
                attributes.divisionEnergyRatio = 0.3 + (energyRatioRaw * 0.4);
            }
            
            // 解釈結果を保存
            this.genome.expression = attributes;
            
            // 現在の属性を更新
            this.updateAttributes(attributes);
            
            return attributes;
        }
        
        // 遺伝子のセグメントを0-1の値に変換
        interpretGenomeSegment(sequence, start, end) {
            const segment = sequence.slice(start, end);
            let value = 0;
            let divisor = 1;
            
            // 単純な平均値計算（1の数/ビット数）
            for (let i = 0; i < segment.length; i++) {
                value += segment[i];
            }
            
            return value / segment.length;
        }
        
        // 属性の更新
        updateAttributes(newAttributes) {
            // 既存の属性がなければ初期化
            if (!this.attributes) {
                this.attributes = {};
            }
            
            // 属性を更新
            Object.keys(newAttributes).forEach(key => {
                this.attributes[key] = newAttributes[key];
            });
        }
    }
    
    // 環境クラス - エネルギー場や環境条件を提供
    class Environment {
        constructor() {
            // 環境のノイズシード
            this.seedX = Math.random() * 1000;
            this.seedY = Math.random() * 1000;
            
            // 環境エネルギーフィールドの初期化
            this.energyField = Array(width * height).fill().map(() => ({
                energy: 0,
                weight: 0
            }));
            
            // 初期エネルギー分布の設定
            let totalEntityEnergy = 0;
            for (const entity of entities) {
                if (entity && entity.isActive) {
                    totalEntityEnergy += entity.energy || 0;
                }
            }
            
            // 残りのエネルギーを環境に分配
            const environmentEnergy = Math.max(0, TOTAL_SYSTEM_ENERGY - totalEntityEnergy);
            this.initializeEnergyField(environmentEnergy);
        }
        
        // 環境エネルギーフィールドの初期化
        initializeEnergyField(totalEnvironmentEnergy) {
            let totalDistributionWeight = 0;
            
            // 初期分布の重みを計算
            for (let i = 0; i < this.energyField.length; i++) {
                const x = i % width;
                const y = Math.floor(i / width);
                
                // 単純なノイズ関数でエネルギー分布の重みを決定
                const nx = (x * 0.05 + this.seedX);
                const ny = (y * 0.05 + this.seedY);
                // より対称的な分布を生成
                const weight = (Math.sin(nx) * Math.sin(ny) + 1) / 2;  // 0～1の範囲
                
                this.energyField[i] = {
                    energy: 0,
                    weight: weight
                };
                
                totalDistributionWeight += weight;
            }
            
            // 重みに基づいてエネルギーを分配
            for (let i = 0; i < this.energyField.length; i++) {
                this.energyField[i].energy = 
                    (this.energyField[i].weight / totalDistributionWeight) * totalEnvironmentEnergy;
            }
        }
        
        // 指定位置でのエネルギー量を取得し、その分環境から減少させる
        getEnergyAt(position, time, amount) {
            const x = Math.floor(position.x);
            const y = Math.floor(position.y);
            
            // 範囲外チェック
            if (x < 0 || x >= width || y < 0 || y >= height) return 0;
            
            const index = y * width + x;
            const availableEnergy = this.energyField[index].energy;
            
            // 要求量と利用可能量の小さい方を取得
            const extractedEnergy = Math.min(amount, availableEnergy);
            
            // 環境からエネルギーを減少
            this.energyField[index].energy -= extractedEnergy;
            
            return extractedEnergy;
        }
        
        // エネルギーを環境に戻す
        returnEnergyAt(position, amount) {
            if (!position || typeof amount !== 'number') return;
            
            const x = Math.floor(position.x);
            const y = Math.floor(position.y);
            
            // 範囲外チェック
            if (x < 0 || x >= width || y < 0 || y >= height) return;
            
            const index = y * width + x;
            if (!this.energyField[index]) {
                this.energyField[index] = { energy: 0, weight: 0 };
            }
            
            this.energyField[index].energy += amount;
        }
        
        // エネルギーの拡散（各フレームで呼び出す）
        diffuseEnergy() {
            const diffusionRate = 0.05;
            const newField = [...this.energyField];
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = y * width + x;
                    const currentEnergy = this.energyField[index].energy;
                    
                    // 拡散するエネルギー量
                    const diffusionAmount = currentEnergy * diffusionRate;
                    
                    // 自身は拡散分減少
                    newField[index].energy -= diffusionAmount;
                    
                    // 隣接セルに拡散（4方向）
                    const directions = [
                        {dx: 1, dy: 0}, {dx: -1, dy: 0},
                        {dx: 0, dy: 1}, {dx: 0, dy: -1}
                    ];
                    
                    for (const dir of directions) {
                        const nx = x + dir.dx;
                        const ny = y + dir.dy;
                        
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const neighborIndex = ny * width + nx;
                            newField[neighborIndex].energy += diffusionAmount / 4;
                        }
                    }
                }
            }
            
            this.energyField = newField;
        }
    }
    
    // エンティティと環境の初期化
    const entities = [];
    const environment = new Environment();
    
    // コロニー状の初期配置を行う関数
    function createInitialColony() {
        // コロニーの中心位置（画面中央）
        const centerX = width * 0.5;
        const centerY = height * 0.5;
        
        // コロニーのサイズ
        const colonyRadius = 5;
        
        // 大腸菌型の初期生命の属性
        const bacterialAttributes = {
            sensorSensitivity: 0.7,     // より高い感度
            energyConversion: 0.8,      // 高いエネルギー変換効率
            movementEfficiency: 0.7,    // 効率的な運動能力
            responseRate: 0.6,          // より高い応答性
            structuralIntegrity: 0.8    // より高い構造強度
        };
        
        // 密集度を調整しながらエンティティを配置
        for (let i = 0; i < initialEntityCount; i++) {
            // 極座標でランダムな位置を生成
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * colonyRadius;
            
            // 極座標から直交座標に変換
            const offsetX = Math.cos(angle) * radius;
            const offsetY = Math.sin(angle) * radius;
            
            // 最終位置の計算
            const x = centerX + offsetX;
            const y = centerY + offsetY;
            
            // エンティティの作成と追加
            entities.push(new Entity(x, y, null, bacterialAttributes));
        }
    }
    
    // 初期コロニーの作成
    createInitialColony();
    
    // Z-bufferの初期化（表示用）
    function initZBuffer() {
        const buffer = [];
        for (let i = 0; i < width * height; i++) {
            buffer.push({
                char: ' ',
                depth: Infinity,
                color: ''
            });
        }
        return buffer;
    }
    
    // エンティティの色を計算
    function getEntityColor(entity) {
        if (!entity.genome || !entity.genome.core || !entity.genome.core.sequence) {
            // フォールバックの色をより明るく
            return `rgba(230, 230, 230, ${0.7 + entity.energy * 0.3})`;
        }
        
        // コア遺伝子配列から色を生成
        const sequence = entity.genome.core.sequence;
        const segmentLength = Math.floor(sequence.length / 3);
        
        // RGBの各要素に配列を分割
        const rSegment = sequence.slice(0, segmentLength);
        const gSegment = sequence.slice(segmentLength, segmentLength * 2);
        const bSegment = sequence.slice(segmentLength * 2, segmentLength * 3);
        
        // バイナリ配列を色値に変換（より鮮やかな色になるように調整）
        const r = Math.floor(180 + entity.binaryToValue(rSegment) * 75); // 180-255の範囲
        const g = Math.floor(180 + entity.binaryToValue(gSegment) * 75); // 180-255の範囲
        const b = Math.floor(180 + entity.binaryToValue(bSegment) * 75); // 180-255の範囲
        
        // 不透明度を上げて、より見やすく
        const alpha = 0.8 + entity.energy * 0.2; // 最小0.8、最大1.0
        
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    
    // フレームの描画
    function render() {
        // 現在の実時間を取得
        const realTime = performance.now() / 1000;  // 秒単位の実時間
        
        // フレームカウンターを増加
        frameCount++;
        
        // 一時停止中なら更新しない
        if (!paused) {
            // エンティティの更新
            for (let i = entities.length - 1; i >= 0; i--) {
                const entity = entities[i];
                if (!entity || !entity.isActive) {
                    entities.splice(i, 1);
                    continue;
                }
                
                // 主観的時間スケールを計算して更新（シミュレーション速度も反映）
                entity.update(entities, environment, calculateSubjectiveTime(entity, realTime) * simulationSpeed);
            }
            
            // 環境エネルギーの拡散（シミュレーション速度に応じて）
            if (frameCount % Math.max(1, Math.round(10 / simulationSpeed)) === 0) {
                environment.diffuseEnergy();
            }
        }
        
        // シミュレーションメトリクスの収集（一時停止中も収集）
        collectSimulationData();
        
        // 統計グラフの更新
        if (showStats && frameCount % 30 === 0) {
            updateStatsDisplay();
        }
        
        // エンティティの描画
        const displayBuffer = Array(width * height).fill(null).map(() => ({
            char: ' ',
            color: ''
        }));
        
        // バッファにエンティティを描画
        for (const entity of entities) {
            if (!entity || !entity.isActive) continue;
            
            const projectedX = Math.floor(entity.position.x);
            const projectedY = Math.floor(entity.position.y);
            
            if (projectedX >= 0 && projectedX < width && projectedY >= 0 && projectedY < height) {
                const bufferIndex = projectedY * width + projectedX;
                
                // 密度とエネルギーに基づく文字選択
                const charIndex = Math.floor((entity.density * entity.energy) * (asciiChars.length - 1));
                const displayChar = asciiChars[Math.min(Math.max(0, charIndex), asciiChars.length - 1)];
                
                displayBuffer[bufferIndex] = {
                    char: displayChar,
                    color: getEntityColor(entity)
                };
            }
        }
        
        // バッファから文字列を生成して描画
        let output = '';
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = y * width + x;
                const cell = displayBuffer[index];
                output += cell.char !== ' ' ? `<span style="color:${cell.color}">${cell.char}</span>` : '&nbsp;';
            }
            output += '<br>';
        }
        
        canvas.innerHTML = output;
        
        // 次のフレーム
        time++;
        
        // 環境のエネルギー拡散
        environment.diffuseEnergy();
        
        // エネルギー保存の検証（デバッグ用）
        if (time % 100 === 0) {
            let totalEnergy = 0;
            
            // エンティティのエネルギー
            for (const entity of entities) {
                if (entity && entity.isActive) {
                    totalEnergy += entity.energy;
                }
            }
            
            // 環境のエネルギー
            for (const cell of environment.energyField) {
                if (cell) {
                    totalEnergy += cell.energy;
                }
            }
            
            console.log(`Time: ${time}, Total Energy: ${totalEnergy}, Target: ${TOTAL_SYSTEM_ENERGY}`);
        }
        
        // 10FPSに制限
        setTimeout(() => {
            requestAnimationFrame(render);
        }, 33); // 100ms = 10FPS
    }
    
    // エンティティごとの主観的時間を計算 - 昼夜サイクル要素なし
    function calculateSubjectiveTime(entity, realTime) {
        // エネルギーレベルと知覚能力に基づく時間スケール
        const baseFactor = (0.5 + entity.energy) * (entity.attributes.sensorSensitivity * 0.5 + 0.5);
        
        // 実時間変動要素
        const timeGapFactor = Math.sin(realTime * 0.1) * 0.2 + 1.0;
        
        return baseFactor * timeGapFactor;
    }
    
    // シミュレーション開始
    render();
    
    // ウィンドウサイズ変更時の処理
    window.addEventListener('resize', () => {
        // フォントサイズを調整（正方形のグリッドになるように）
        const fontWidth = Math.floor(window.innerWidth / width);
        const fontHeight = Math.floor(window.innerHeight / height);
        const fontSize = Math.min(fontWidth, fontHeight);
        canvas.style.fontSize = `${fontSize}px`;
    });
    
    // 初期フォントサイズ設定
    const fontWidth = Math.floor(window.innerWidth / width);
    const fontHeight = Math.floor(window.innerHeight / height);
    const fontSize = Math.min(fontWidth, fontHeight);
    canvas.style.fontSize = `${fontSize}px`;

    // シミュレーションデータの収集と分析
    let simulationData = {
        timestamps: [],
        populationSize: [],
        averageEnergy: [],
        geneticDiversity: [],
        interactionStats: {},
        environmentalEnergy: [],
        geneticAnalytics: {  // Add genetic analytics section
            dominantGenes: [],
            geneFrequency: {},
            mutationEvents: [],
            speciation: []
        },
        experimentMetadata: {
            name: "Default Experiment",
            description: "",
            startTime: new Date().toISOString(),
            parameters: {}
        }
    };
    
    function collectSimulationData() {
        // 定期的なデータ収集（例：100フレームごと）
        if (frameCount % 100 !== 0) return;
        
        const currentTime = performance.now() / 1000;
        simulationData.timestamps.push(currentTime);
        simulationData.populationSize.push(entities.length);
        
        // 平均エネルギー計算
        const totalEnergy = entities.reduce((sum, entity) => sum + entity.energy, 0);
        const avgEnergy = entities.length > 0 ? totalEnergy / entities.length : 0;
        simulationData.averageEnergy.push(avgEnergy);
        
        // 遺伝的多様性の計算
        simulationData.geneticDiversity.push(calculateGeneticDiversity());
        
        // 環境エネルギーの記録
        const totalEnvironmentalEnergy = calculateTotalEnvironmentalEnergy();
        simulationData.environmentalEnergy.push(totalEnvironmentalEnergy);
        
        // Enhanced genetic analytics
        collectGeneticAnalytics();
        
        // データが多すぎる場合は古いデータを削除
        const maxDataPoints = 1000;
        if (simulationData.timestamps.length > maxDataPoints) {
            for (const key in simulationData) {
                if (Array.isArray(simulationData[key])) {
                    simulationData[key] = simulationData[key].slice(-maxDataPoints);
                }
            }
        }
    }
    
    // New function to collect detailed genetic analytics
    function collectGeneticAnalytics() {
        if (entities.length === 0) return;
        
        // Gene frequency analysis
        const geneFrequency = {};
        
        // Count gene patterns across population
        entities.forEach(entity => {
            if (!entity.genome?.coreGenes) return;
            
            // Analyze gene sequences in chunks
            for (let i = 0; i < entity.genome.coreGenes.length - 3; i += 4) {
                const geneSequence = entity.genome.coreGenes.slice(i, i + 4).join('');
                if (!geneFrequency[geneSequence]) {
                    geneFrequency[geneSequence] = 0;
                }
                geneFrequency[geneSequence]++;
            }
        });
        
        // Find dominant genes (top 5)
        const dominantGenes = Object.entries(geneFrequency)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(([gene, count]) => ({
                sequence: gene,
                count,
                frequency: count / entities.length
            }));
        
        // Update simulation data
        simulationData.geneticAnalytics.dominantGenes.push({
            timestamp: performance.now() / 1000,
            dominantGenes
        });
        
        // Store current gene frequency snapshot
        simulationData.geneticAnalytics.geneFrequency[performance.now() / 1000] = geneFrequency;
        
        // Speciation analysis (basic clustering)
        const speciesGroups = analyzeSpeciation();
        simulationData.geneticAnalytics.speciation.push({
            timestamp: performance.now() / 1000,
            speciesCount: speciesGroups.length,
            distribution: speciesGroups.map(group => group.length),
        });
    }
    
    // Function to analyze potential speciation
    function analyzeSpeciation() {
        if (entities.length <= 1) return [entities];
        
        // Simple clustering algorithm based on genetic similarity
        const similarityThreshold = 0.7; // Entities with similarity above this are considered same species
        const clusters = [];
        
        // Clone entities array to avoid modifying the original
        const remainingEntities = [...entities];
        
        while (remainingEntities.length > 0) {
            const current = remainingEntities.shift();
            const cluster = [current];
            
            // Find all entities similar to the current one
            for (let i = remainingEntities.length - 1; i >= 0; i--) {
                const similarity = current.calculateGeneticSimilarity(remainingEntities[i]);
                if (similarity >= similarityThreshold) {
                    cluster.push(remainingEntities[i]);
                    remainingEntities.splice(i, 1);
                }
            }
            
            clusters.push(cluster);
        }
        
        return clusters;
    }
    
    function calculateGeneticDiversity() {
        if (entities.length <= 1) return 0;
        
        // サンプリングした個体間の遺伝的類似性を計算
        const sampleSize = Math.min(entities.length, 20); // 最大20個体をサンプリング
        const samples = [];
        
        // ランダムサンプリング
        const entityCopy = [...entities];
        for (let i = 0; i < sampleSize; i++) {
            const randomIndex = Math.floor(Math.random() * entityCopy.length);
            samples.push(entityCopy.splice(randomIndex, 1)[0]);
        }
        
        // 全ペアの類似性の平均を計算
        let totalSimilarity = 0;
        let pairCount = 0;
        
        for (let i = 0; i < samples.length; i++) {
            for (let j = i + 1; j < samples.length; j++) {
                const similarity = samples[i].calculateGeneticSimilarity(samples[j]);
                totalSimilarity += similarity;
                pairCount++;
            }
        }
        
        // 平均類似性から多様性を計算（1 - 平均類似性）
        return pairCount > 0 ? 1 - (totalSimilarity / pairCount) : 0;
    }
    
    function calculateTotalEnvironmentalEnergy() {
        // 環境のエネルギー総量を計算
        let totalEnergy = 0;
        for (let y = 0; y < environment.height; y++) {
            for (let x = 0; x < environment.width; x++) {
                totalEnergy += environment.getEnergyAt({x, y}, performance.now() / 1000, 0);
            }
        }
        return totalEnergy;
    }
    
    // データのエクスポート機能
    function exportSimulationData() {
        // メタデータを最新情報に更新
        simulationData.experimentMetadata.endTime = new Date().toISOString();
        simulationData.experimentMetadata.duration = (new Date() - new Date(simulationData.experimentMetadata.startTime)) / 1000; // 秒単位
        simulationData.experimentMetadata.finalPopulation = entities.length;
        
        // 現在のシミュレーションパラメータを記録
        simulationData.experimentMetadata.parameters = {
            ...simulationData.experimentMetadata.parameters,
            currentPopulation: entities.length,
            simulationTime: performance.now() / 1000,
            frameCount: frameCount
        };
        
        const dataStr = JSON.stringify(simulationData, null, 2); // 整形JSONで出力
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const experimentName = simulationData.experimentMetadata.name.replace(/\s+/g, '_').toLowerCase();
        const exportFileDefaultName = `alife_exp_${experimentName}_${new Date().toISOString().replace(/:/g, '-')}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
    }
    
    // データのインポート機能
    function importSimulationData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // 基本的な検証
                    if (!importedData.experimentMetadata || !importedData.timestamps) {
                        alert('無効な実験データファイルです');
                        return;
                    }
                    
                    // データをインポート
                    simulationData = importedData;
                    
                    // UI更新
                    if (showStats) {
                        updateStatsDisplay();
                    }
                    
                    alert(`実験データ "${simulationData.experimentMetadata.name}" をインポートしました`);
                } catch (error) {
                    alert('データのインポートに失敗しました: ' + error.message);
                }
            };
            
            reader.readAsText(file);
        };
        
        input.click();
    }

    // ここに新しいUI要素の初期化コードを追加
    function initializeUI() {
        // Control panel
        const controlPanel = document.createElement('div');
        controlPanel.id = 'control-panel';
        controlPanel.style.position = 'absolute';
        controlPanel.style.top = '10px';
        controlPanel.style.right = '10px';
        controlPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        controlPanel.style.padding = '10px';
        controlPanel.style.borderRadius = '5px';
        controlPanel.style.color = 'white';
        controlPanel.style.fontFamily = 'monospace';
        controlPanel.style.zIndex = '1000';
        controlPanel.style.maxWidth = '250px';
        
        // Simulation controls section
        const controlsSection = document.createElement('div');
        controlsSection.innerHTML = '<h4>Controls</h4>';
        
        // Pause/resume button
        const pauseButton = document.createElement('button');
        pauseButton.textContent = 'Pause';
        pauseButton.style.marginRight = '5px';
        pauseButton.onclick = function() {
            paused = !paused;
            pauseButton.textContent = paused ? 'Resume' : 'Pause';
        };
        
        // Add entity button
        const addEntityButton = document.createElement('button');
        addEntityButton.textContent = 'Add Entity';
        addEntityButton.onclick = function() {
            const x = Math.random() * width;
            const y = Math.random() * height;
            entities.push(new Entity(x, y));
        };
        
        // Button container for first row
        const buttonRow1 = document.createElement('div');
        buttonRow1.style.display = 'flex';
        buttonRow1.style.marginBottom = '10px';
        buttonRow1.appendChild(pauseButton);
        buttonRow1.appendChild(addEntityButton);
        controlsSection.appendChild(buttonRow1);
        
        // Speed slider
        const speedLabel = document.createElement('div');
        speedLabel.textContent = 'Speed: 1.0x';
        speedLabel.style.marginBottom = '5px';
        
        const speedSlider = document.createElement('input');
        speedSlider.type = 'range';
        speedSlider.min = '0.1';
        speedSlider.max = '5';
        speedSlider.step = '0.1';
        speedSlider.value = '1';
        speedSlider.style.width = '100%';
        speedSlider.style.marginBottom = '10px';
        speedSlider.oninput = function() {
            simulationSpeed = parseFloat(this.value);
            speedLabel.textContent = `Speed: ${simulationSpeed.toFixed(1)}x`;
        };
        
        controlsSection.appendChild(speedLabel);
        controlsSection.appendChild(speedSlider);
        
        // View toggle and data buttons
        const statsToggle = document.createElement('button');
        statsToggle.textContent = 'Show Stats';
        statsToggle.style.marginRight = '5px';
        statsToggle.onclick = function() {
            showStats = !showStats;
            statsToggle.textContent = showStats ? 'Hide Stats' : 'Show Stats';
            statsPanel.style.display = showStats ? 'block' : 'none';
        };
        
        // Export/Import buttons
        const exportButton = document.createElement('button');
        exportButton.textContent = 'Export';
        exportButton.style.marginRight = '5px';
        exportButton.onclick = exportSimulationData;
        
        const importButton = document.createElement('button');
        importButton.textContent = 'Import';
        importButton.onclick = importSimulationData;
        
        // Button container for second row
        const buttonRow2 = document.createElement('div');
        buttonRow2.style.display = 'flex';
        buttonRow2.style.marginBottom = '10px';
        buttonRow2.appendChild(statsToggle);
        buttonRow2.appendChild(exportButton);
        buttonRow2.appendChild(importButton);
        controlsSection.appendChild(buttonRow2);
        
        // Experiment preset selection
        const presetLabel = document.createElement('div');
        presetLabel.textContent = 'Experiment:';
        presetLabel.style.marginBottom = '5px';
        
        const presetSelect = document.createElement('select');
        presetSelect.style.width = '100%';
        presetSelect.style.marginBottom = '10px';
        
        const presets = [
            { name: 'Default', value: 'default' },
            { name: 'High Energy', value: 'high-energy' },
            { name: 'Low Energy', value: 'low-energy' },
            { name: 'High Mutation', value: 'high-mutation' },
            { name: 'Cooperative', value: 'cooperative' },
            { name: 'Competitive', value: 'competitive' }
        ];
        
        presets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.value;
            option.textContent = preset.name;
            presetSelect.appendChild(option);
        });
        
        presetSelect.onchange = function() {
            applyExperimentPreset(this.value);
        };
        
        controlsSection.appendChild(presetLabel);
        controlsSection.appendChild(presetSelect);
        
        // Parameters section
        const parameterSection = document.createElement('div');
        parameterSection.innerHTML = '<h4>Parameters</h4>';
        
        // Mutation rate
        const mutationLabel = document.createElement('div');
        mutationLabel.textContent = 'Mutation rate: ';
        const mutationValue = document.createElement('span');
        mutationValue.textContent = '0.01';
        mutationLabel.appendChild(mutationValue);
        
        const mutationSlider = document.createElement('input');
        mutationSlider.type = 'range';
        mutationSlider.min = '0';
        mutationSlider.max = '0.1';
        mutationSlider.step = '0.001';
        mutationSlider.value = '0.01';
        mutationSlider.style.width = '100%';
        mutationSlider.style.marginBottom = '10px';
        mutationSlider.oninput = function() {
            Entity.MUTATION_RATE = parseFloat(this.value);
            mutationValue.textContent = Entity.MUTATION_RATE.toFixed(3);
        };
        
        parameterSection.appendChild(mutationLabel);
        parameterSection.appendChild(mutationSlider);
        
        // Metadata mini-section
        const nameLabel = document.createElement('div');
        nameLabel.textContent = 'Experiment name:';
        nameLabel.style.marginBottom = '5px';
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = simulationData.experimentMetadata.name;
        nameInput.style.width = '100%';
        nameInput.style.marginBottom = '10px';
        nameInput.oninput = function() {
            simulationData.experimentMetadata.name = this.value;
        };
        
        parameterSection.appendChild(nameLabel);
        parameterSection.appendChild(nameInput);
        
        // Add sections to control panel
        controlPanel.appendChild(controlsSection);
        controlPanel.appendChild(parameterSection);
        
        document.body.appendChild(controlPanel);
        
        // Stats panel
        const statsPanel = document.createElement('div');
        statsPanel.id = 'stats-panel';
        statsPanel.style.position = 'absolute';
        statsPanel.style.top = '10px';
        statsPanel.style.left = '10px';
        statsPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        statsPanel.style.padding = '10px';
        statsPanel.style.borderRadius = '5px';
        statsPanel.style.color = 'white';
        statsPanel.style.fontFamily = 'monospace';
        statsPanel.style.display = 'none';
        statsPanel.style.zIndex = '1000';
        statsPanel.style.maxWidth = '300px';
        statsPanel.style.maxHeight = '80vh';
        statsPanel.style.overflowY = 'auto';
        
        // Graph canvases
        const populationGraph = document.createElement('canvas');
        populationGraph.id = 'population-graph';
        populationGraph.width = 280;
        populationGraph.height = 120;
        
        const energyGraph = document.createElement('canvas');
        energyGraph.id = 'energy-graph';
        energyGraph.width = 280;
        energyGraph.height = 120;
        
        const diversityGraph = document.createElement('canvas');
        diversityGraph.id = 'diversity-graph';
        diversityGraph.width = 280;
        diversityGraph.height = 120;
        
        statsPanel.innerHTML = '<h3>Simulation Stats</h3>';
        
        // Tab-style navigation for stats with enhanced research tabs
        const tabContainer = document.createElement('div');
        tabContainer.style.display = 'flex';
        tabContainer.style.marginBottom = '10px';
        
        const graphsTab = document.createElement('button');
        graphsTab.textContent = 'Graphs';
        graphsTab.style.flex = '1';
        graphsTab.style.backgroundColor = '#444';
        graphsTab.style.border = 'none';
        graphsTab.style.padding = '5px';
        graphsTab.style.color = 'white';
        
        const speciesTab = document.createElement('button');
        speciesTab.textContent = 'Species';
        speciesTab.style.flex = '1';
        speciesTab.style.backgroundColor = '#222';
        speciesTab.style.border = 'none';
        speciesTab.style.padding = '5px';
        speciesTab.style.color = 'white';
        
        const genesTab = document.createElement('button');
        genesTab.textContent = 'Genes';
        genesTab.style.flex = '1';
        genesTab.style.backgroundColor = '#222';
        genesTab.style.border = 'none';
        genesTab.style.padding = '5px';
        genesTab.style.color = 'white';
        
        const entityTab = document.createElement('button');
        entityTab.textContent = 'Entity';
        entityTab.style.flex = '1';
        entityTab.style.backgroundColor = '#222';
        entityTab.style.border = 'none';
        entityTab.style.padding = '5px';
        entityTab.style.color = 'white';
        
        tabContainer.appendChild(graphsTab);
        tabContainer.appendChild(speciesTab);
        tabContainer.appendChild(genesTab);
        tabContainer.appendChild(entityTab);
        statsPanel.appendChild(tabContainer);
        
        // Content containers
        const graphsContainer = document.createElement('div');
        graphsContainer.id = 'graphs-container';
        
        const speciesContainer = document.createElement('div');
        speciesContainer.id = 'species-container';
        speciesContainer.innerHTML = '<p>Species data will appear here when available</p>';
        speciesContainer.style.display = 'none';
        
        const genesContainer = document.createElement('div');
        genesContainer.id = 'genes-container';
        genesContainer.innerHTML = '<p>Gene data will appear here when available</p>';
        genesContainer.style.display = 'none';
        
        const entityContainer = document.createElement('div');
        entityContainer.id = 'entity-details';
        entityContainer.innerHTML = '<p>Click on an entity to view details</p>';
        entityContainer.style.display = 'none';
        
        // Add graphs to graphs container
        graphsContainer.appendChild(document.createElement('h4')).textContent = 'Population';
        graphsContainer.appendChild(populationGraph);
        graphsContainer.appendChild(document.createElement('h4')).textContent = 'Energy';
        graphsContainer.appendChild(energyGraph);
        graphsContainer.appendChild(document.createElement('h4')).textContent = 'Genetic Diversity';
        graphsContainer.appendChild(diversityGraph);
        
        statsPanel.appendChild(graphsContainer);
        statsPanel.appendChild(speciesContainer);
        statsPanel.appendChild(genesContainer);
        statsPanel.appendChild(entityContainer);
        
        // Tab switching logic
        graphsTab.onclick = function() {
            graphsContainer.style.display = 'block';
            speciesContainer.style.display = 'none';
            genesContainer.style.display = 'none';
            entityContainer.style.display = 'none';
            graphsTab.style.backgroundColor = '#444';
            speciesTab.style.backgroundColor = '#222';
            genesTab.style.backgroundColor = '#222';
            entityTab.style.backgroundColor = '#222';
        };
        
        speciesTab.onclick = function() {
            graphsContainer.style.display = 'none';
            speciesContainer.style.display = 'block';
            genesContainer.style.display = 'none';
            entityContainer.style.display = 'none';
            graphsTab.style.backgroundColor = '#222';
            speciesTab.style.backgroundColor = '#444';
            genesTab.style.backgroundColor = '#222';
            entityTab.style.backgroundColor = '#222';
            updateSpeciesDisplay();
        };
        
        genesTab.onclick = function() {
            graphsContainer.style.display = 'none';
            speciesContainer.style.display = 'none';
            genesContainer.style.display = 'block';
            entityContainer.style.display = 'none';
            graphsTab.style.backgroundColor = '#222';
            speciesTab.style.backgroundColor = '#222';
            genesTab.style.backgroundColor = '#444';
            entityTab.style.backgroundColor = '#222';
            updateGeneFrequencyDisplay();
        };
        
        entityTab.onclick = function() {
            graphsContainer.style.display = 'none';
            speciesContainer.style.display = 'none';
            genesContainer.style.display = 'none';
            entityContainer.style.display = 'block';
            graphsTab.style.backgroundColor = '#222';
            speciesTab.style.backgroundColor = '#222';
            genesTab.style.backgroundColor = '#222';
            entityTab.style.backgroundColor = '#444';
        };
        
        document.body.appendChild(statsPanel);
        
        // Entity selection event
        canvas.addEventListener('click', function(event) {
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Convert to canvas position
            const canvasX = (clickX / rect.width) * width;
            const canvasY = (clickY / rect.height) * height;
            
            // Find closest entity
            let closestEntity = null;
            let minDistance = Infinity;
            
            for (const entity of entities) {
                const distance = Math.sqrt(
                    Math.pow(entity.position.x - canvasX, 2) + 
                    Math.pow(entity.position.y - canvasY, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestEntity = entity;
                }
            }
            
            // Select if entity is close enough
            if (minDistance < 5 && closestEntity) {
                selectedEntity = closestEntity;
                updateEntityDetails(selectedEntity);
                
                // Switch to entity tab
                graphsContainer.style.display = 'none';
                entityContainer.style.display = 'block';
                graphsTab.style.backgroundColor = '#222';
                entityTab.style.backgroundColor = '#444';
            }
        });
    }
    
    function updateStatsDisplay() {
        if (!showStats) return;
        
        // Get latest stats data (max 100 points)
        const dataPoints = Math.min(simulationData.timestamps.length, 100);
        const timestamps = simulationData.timestamps.slice(-dataPoints);
        const populations = simulationData.populationSize.slice(-dataPoints);
        const energyData = simulationData.averageEnergy.slice(-dataPoints);
        const diversityData = simulationData.geneticDiversity.slice(-dataPoints);
        
        // Draw graphs
        drawGraph('population-graph', timestamps, populations, 'Population', 'rgb(0, 200, 0)');
        drawGraph('energy-graph', timestamps, energyData, 'Energy', 'rgb(255, 165, 0)');
        drawGraph('diversity-graph', timestamps, diversityData, 'Diversity', 'rgb(75, 192, 192)');
        
        // Update species data if available and species tab is selected
        if (document.getElementById('species-container') && 
            document.getElementById('species-container').style.display !== 'none' &&
            simulationData.geneticAnalytics.speciation.length > 0) {
            updateSpeciesDisplay();
        }
        
        // Update gene frequency data if available and genes tab is selected
        if (document.getElementById('genes-container') &&
            document.getElementById('genes-container').style.display !== 'none' &&
            simulationData.geneticAnalytics.dominantGenes.length > 0) {
            updateGeneFrequencyDisplay();
        }
        
        // Update selected entity details
        if (selectedEntity && selectedEntity.isActive) {
            updateEntityDetails(selectedEntity);
        } else {
            selectedEntity = null;
            document.getElementById('entity-details').innerHTML = '<p>Click on an entity to view details</p>';
        }
    }
    
    function drawGraph(canvasId, xData, yData, label, color) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Axis
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        ctx.lineTo(canvas.width, canvas.height);
        ctx.stroke();
        
        if (yData.length < 2) return;
        
        // Draw data if available
        const maxY = Math.max(...yData) * 1.1 || 1; // Prevent division by zero
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let i = 0; i < yData.length; i++) {
            const x = (i / (yData.length - 1)) * canvas.width;
            const y = canvas.height - (yData[i] / maxY) * canvas.height;
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();
        
        // Labels and current value
        ctx.fillStyle = 'white';
        ctx.font = '12px monospace';
        ctx.fillText(`${label}: ${yData[yData.length - 1].toFixed(2)}`, 5, 15);
        ctx.fillText(`Max: ${maxY.toFixed(2)}`, 5, 30);
    }
    
    function updateEntityDetails(entity) {
        const detailsDiv = document.getElementById('entity-details');
        detailsDiv.innerHTML = `
            <h4>Entity #${entity.id}</h4>
            <table style="width:100%; border-collapse:collapse;">
                <tr><td>Energy:</td><td>${entity.energy.toFixed(3)}</td></tr>
                <tr><td>Density:</td><td>${entity.density.toFixed(3)}</td></tr>
                <tr><td>Age:</td><td>${entity.age.toFixed(0)}</td></tr>
                <tr><td>Position:</td><td>(${entity.position.x.toFixed(1)}, ${entity.position.y.toFixed(1)})</td></tr>
                <tr><td>Velocity:</td><td>(${entity.velocity.x.toFixed(2)}, ${entity.velocity.y.toFixed(2)})</td></tr>
            </table>
            
            <h5>Genetic Stats</h5>
            <table style="width:100%; border-collapse:collapse;">
                <tr><td>Core genes:</td><td>${entity.genome?.coreGenes?.length || 0}</td></tr>
                <tr><td>Regulatory genes:</td><td>${Object.keys(entity.genome?.regulatory || {}).length}</td></tr>
                <tr><td>Defense genes:</td><td>${Object.keys(entity.genome?.defense || {}).length}</td></tr>
                <tr><td>Behavior patterns:</td><td>${Object.keys(entity.genome?.behavior || {}).length}</td></tr>
            </table>
            
            <h5>Interaction History</h5>
            <table style="width:100%; border-collapse:collapse;">
                <tr><td>Cooperative:</td><td>${entity.interactionHistory?.cooperative || 0}</td></tr>
                <tr><td>Hostile:</td><td>${entity.interactionHistory?.hostile || 0}</td></tr>
                <tr><td>Neutral:</td><td>${entity.interactionHistory?.neutral || 0}</td></tr>
            </table>
        `;
        
        // Genome details button
        const genomeButton = document.createElement('button');
        genomeButton.textContent = 'View Genome';
        genomeButton.style.marginTop = '10px';
        genomeButton.onclick = function() {
            showGenomeDetails(entity);
        };
        detailsDiv.appendChild(genomeButton);
    }
    
    function showGenomeDetails(entity) {
        // Modal window
        const modal = document.createElement('div');
        modal.style.position = 'fixed';
        modal.style.top = '10%';
        modal.style.left = '10%';
        modal.style.width = '80%';
        modal.style.height = '80%';
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
        modal.style.color = 'white';
        modal.style.padding = '20px';
        modal.style.overflowY = 'auto';
        modal.style.zIndex = '2000';
        modal.style.fontFamily = 'monospace';
        modal.style.fontSize = '12px';
        
        // Close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.position = 'absolute';
        closeButton.style.top = '10px';
        closeButton.style.right = '10px';
        closeButton.onclick = function() {
            document.body.removeChild(modal);
        };
        
        modal.innerHTML = `<h3>Entity #${entity.id} Genome Details</h3>`;
        modal.appendChild(closeButton);
        
        // Core genes display
        const coreGenesDiv = document.createElement('div');
        coreGenesDiv.innerHTML = '<h4>Core Gene Sequence</h4>';
        
        if (entity.genome?.coreGenes) {
            const pre = document.createElement('pre');
            pre.style.overflowX = 'auto';
            pre.style.backgroundColor = 'rgba(50, 50, 50, 0.5)';
            pre.style.padding = '10px';
            
            let formattedGenes = '';
            for (let i = 0; i < entity.genome.coreGenes.length; i++) {
                if (i > 0 && i % 8 === 0) formattedGenes += '\n';
                else if (i > 0) formattedGenes += ' ';
                
                formattedGenes += entity.genome.coreGenes[i];
            }
            
            pre.textContent = formattedGenes;
            coreGenesDiv.appendChild(pre);
        } else {
            coreGenesDiv.innerHTML += '<p>No core gene data available</p>';
        }
        
        modal.appendChild(coreGenesDiv);
        
        // Regulatory genes display
        const regulatoryDiv = document.createElement('div');
        regulatoryDiv.innerHTML = '<h4>Regulatory Genes</h4>';
        
        if (entity.genome?.regulatory && Object.keys(entity.genome.regulatory).length > 0) {
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            
            // Table header
            const thead = document.createElement('thead');
            thead.innerHTML = '<tr><th>Key</th><th>Value</th></tr>';
            table.appendChild(thead);
            
            // Table body
            const tbody = document.createElement('tbody');
            for (const [key, value] of Object.entries(entity.genome.regulatory)) {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${key}</td><td>${JSON.stringify(value)}</td>`;
                tbody.appendChild(row);
            }
            table.appendChild(tbody);
            
            regulatoryDiv.appendChild(table);
        } else {
            regulatoryDiv.innerHTML += '<p>No regulatory gene data available</p>';
        }
        
        modal.appendChild(regulatoryDiv);
        
        document.body.appendChild(modal);
    }
    
    function applyExperimentPreset(presetName) {
        // Update experiment metadata
        simulationData.experimentMetadata.name = presetName;
        simulationData.experimentMetadata.startTime = new Date().toISOString();
        simulationData.experimentMetadata.parameters = {};
        
        switch(presetName) {
            case 'high-energy':
                environment.initializeEnergyField(10000);
                Entity.MUTATION_RATE = 0.01;
                simulationData.experimentMetadata.description = "Evolution in high energy environment";
                simulationData.experimentMetadata.parameters = {
                    environmentalEnergy: 10000,
                    mutationRate: 0.01,
                    cooperationBoost: 1.0,
                    competitionPenalty: 1.0
                };
                break;
            case 'low-energy':
                environment.initializeEnergyField(1000);
                Entity.MUTATION_RATE = 0.01;
                simulationData.experimentMetadata.description = "Survival competition in low energy environment";
                simulationData.experimentMetadata.parameters = {
                    environmentalEnergy: 1000,
                    mutationRate: 0.01,
                    cooperationBoost: 1.0,
                    competitionPenalty: 1.0
                };
                break;
            case 'high-mutation':
                environment.initializeEnergyField(5000);
                Entity.MUTATION_RATE = 0.05;
                document.querySelector('#control-panel input[type="range"]').value = '0.05';
                simulationData.experimentMetadata.description = "Genetic diversity in high mutation environment";
                simulationData.experimentMetadata.parameters = {
                    environmentalEnergy: 5000,
                    mutationRate: 0.05,
                    cooperationBoost: 1.0,
                    competitionPenalty: 1.0
                };
                break;
            case 'cooperative':
                environment.initializeEnergyField(3000);
                Entity.COOPERATION_BOOST = 2.0;
                Entity.COMPETITION_PENALTY = 0.5;
                simulationData.experimentMetadata.description = "Social evolution in cooperative environment";
                simulationData.experimentMetadata.parameters = {
                    environmentalEnergy: 3000,
                    mutationRate: 0.01,
                    cooperationBoost: 2.0,
                    competitionPenalty: 0.5
                };
                break;
            case 'competitive':
                environment.initializeEnergyField(3000);
                Entity.COOPERATION_BOOST = 0.5;
                Entity.COMPETITION_PENALTY = 2.0;
                simulationData.experimentMetadata.description = "Adaptation in competitive environment";
                simulationData.experimentMetadata.parameters = {
                    environmentalEnergy: 3000,
                    mutationRate: 0.01,
                    cooperationBoost: 0.5,
                    competitionPenalty: 2.0
                };
                break;
            default:
                // Default settings
                environment.initializeEnergyField(5000);
                Entity.MUTATION_RATE = 0.01;
                Entity.COOPERATION_BOOST = 1.0;
                Entity.COMPETITION_PENALTY = 1.0;
                simulationData.experimentMetadata.description = "Standard evolution experiment";
                simulationData.experimentMetadata.parameters = {
                    environmentalEnergy: 5000,
                    mutationRate: 0.01,
                    cooperationBoost: 1.0,
                    competitionPenalty: 1.0
                };
        }
        
        // Reset existing data
        resetSimulationData();
        
        // Update UI
        if (document.getElementById('control-panel')) {
            const nameInput = document.querySelector('#control-panel input[type="text"]');
            if (nameInput) nameInput.value = simulationData.experimentMetadata.name;
        }
    }
    
    function resetSimulationData() {
        // Preserve timestamp and experiment metadata
        const metadata = { ...simulationData.experimentMetadata };
        simulationData = {
            timestamps: [],
            populationSize: [],
            averageEnergy: [],
            geneticDiversity: [],
            interactionStats: {},
            environmentalEnergy: [],
            geneticAnalytics: {  // Add genetic analytics section
                dominantGenes: [],
                geneFrequency: {},
                mutationEvents: [],
                speciation: []
            },
            experimentMetadata: metadata
        };
    }
    
    // Data export function
    function exportSimulationData() {
        // Update metadata with latest info
        simulationData.experimentMetadata.endTime = new Date().toISOString();
        simulationData.experimentMetadata.duration = (new Date() - new Date(simulationData.experimentMetadata.startTime)) / 1000; // seconds
        simulationData.experimentMetadata.finalPopulation = entities.length;
        
        // Record current simulation parameters
        simulationData.experimentMetadata.parameters = {
            ...simulationData.experimentMetadata.parameters,
            currentPopulation: entities.length,
            simulationTime: performance.now() / 1000,
            frameCount: frameCount
        };
        
        const dataStr = JSON.stringify(simulationData, null, 2); // formatted JSON
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const experimentName = simulationData.experimentMetadata.name.replace(/\s+/g, '_').toLowerCase();
        const exportFileDefaultName = `alife_${experimentName}_${new Date().toISOString().replace(/:/g, '-')}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
    }
    
    // Data import function
    function importSimulationData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Basic validation
                    if (!importedData.experimentMetadata || !importedData.timestamps) {
                        alert('Invalid experiment data file');
                        return;
                    }
                    
                    // Import data
                    simulationData = importedData;
                    
                    // Update UI
                    if (showStats) {
                        updateStatsDisplay();
                    }
                    
                    alert(`Imported experiment data: "${simulationData.experimentMetadata.name}"`);
                } catch (error) {
                    alert('Failed to import data: ' + error.message);
                }
            };
            
            reader.readAsText(file);
        };
        
        input.click();
    }
    
    // Initialize UI when simulation starts
    window.addEventListener('load', function() {
        initializeUI();
    });
    
    // New function to update species data visualization
    function updateSpeciesDisplay() {
        const speciesContainer = document.getElementById('species-container');
        if (!speciesContainer) return;
        
        // Get latest speciation data
        const speciationData = simulationData.geneticAnalytics.speciation;
        if (speciationData.length === 0) {
            speciesContainer.innerHTML = '<p>No species data available yet</p>';
            return;
        }
        
        const latestData = speciationData[speciationData.length - 1];
        
        // Create species distribution chart
        const canvas = document.getElementById('species-chart');
        if (!canvas) {
            // Create canvas if it doesn't exist
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'species-chart';
            newCanvas.width = 280;
            newCanvas.height = 200;
            speciesContainer.appendChild(newCanvas);
        }
        
        // Draw pie chart for species distribution
        drawSpeciesDistribution('species-chart', latestData.distribution);
        
        // Display species metrics
        const metricsDiv = document.getElementById('species-metrics') || document.createElement('div');
        metricsDiv.id = 'species-metrics';
        
        metricsDiv.innerHTML = `
            <h5>Species Metrics</h5>
            <table style="width:100%; border-collapse:collapse;">
                <tr><td>Number of Species:</td><td>${latestData.speciesCount}</td></tr>
                <tr><td>Largest Species Size:</td><td>${Math.max(...latestData.distribution)}</td></tr>
                <tr><td>Shannon Diversity:</td><td>${calculateShannonDiversity(latestData.distribution).toFixed(3)}</td></tr>
            </table>
        `;
        
        if (!document.getElementById('species-metrics')) {
            speciesContainer.appendChild(metricsDiv);
        }
    }
    
    // Function to draw species distribution pie chart
    function drawSpeciesDistribution(canvasId, distribution) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Skip if no data
        if (distribution.length === 0) {
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('No species data', canvas.width/2, canvas.height/2);
            return;
        }
        
        // Title
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.fillText('Species Distribution', canvas.width/2, 20);
        
        // Draw pie chart
        const total = distribution.reduce((sum, count) => sum + count, 0);
        const radius = Math.min(canvas.width, canvas.height) * 0.4;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2 + 10;
        
        let startAngle = 0;
        const colors = [
            'rgb(255, 99, 132)',
            'rgb(54, 162, 235)',
            'rgb(255, 206, 86)',
            'rgb(75, 192, 192)',
            'rgb(153, 102, 255)',
            'rgb(255, 159, 64)',
            'rgb(199, 199, 199)'
        ];
        
        // Draw each segment
        distribution.forEach((count, index) => {
            const sliceAngle = (count / total) * Math.PI * 2;
            const color = colors[index % colors.length];
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
            ctx.closePath();
            ctx.fill();
            
            // Label if slice is big enough
            if (sliceAngle > 0.2) {
                const labelAngle = startAngle + sliceAngle / 2;
                const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
                const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
                
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${Math.round(count / total * 100)}%`, labelX, labelY);
            }
            
            startAngle += sliceAngle;
        });
        
        // Legend
        const legendY = centerY + radius + 20;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        
        distribution.forEach((count, index) => {
            if (index < 5) { // Show only top 5 species in legend
                const color = colors[index % colors.length];
                const x = 10;
                const y = legendY + index * 20;
                
                ctx.fillStyle = color;
                ctx.fillRect(x, y, 15, 15);
                
                ctx.fillStyle = 'white';
                ctx.fillText(`Species ${index+1}: ${count}`, x + 20, y + 7);
            }
        });
        
        // If more than 5 species, show "Others"
        if (distribution.length > 5) {
            const x = 10;
            const y = legendY + 5 * 20;
            
            ctx.fillStyle = 'white';
            ctx.fillText(`+ ${distribution.length - 5} more species`, x, y + 7);
        }
    }
    
    // Function to update gene frequency visualization
    function updateGeneFrequencyDisplay() {
        const genesContainer = document.getElementById('genes-container');
        if (!genesContainer) return;
        
        // Get latest dominant genes data
        const dominantGenesData = simulationData.geneticAnalytics.dominantGenes;
        if (dominantGenesData.length === 0) {
            genesContainer.innerHTML = '<p>No gene frequency data available yet</p>';
            return;
        }
        
        const latestData = dominantGenesData[dominantGenesData.length - 1];
        
        // Display top genes
        const topGenesDiv = document.createElement('div');
        topGenesDiv.innerHTML = '<h5>Dominant Gene Sequences</h5>';
        
        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.borderCollapse = 'collapse';
        table.style.marginBottom = '15px';
        
        // Table header
        const thead = document.createElement('thead');
        thead.innerHTML = '<tr><th>Sequence</th><th>Count</th><th>Frequency</th></tr>';
        table.appendChild(thead);
        
        // Table body
        const tbody = document.createElement('tbody');
        latestData.dominantGenes.forEach(gene => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><code>${gene.sequence}</code></td>
                <td>${gene.count}</td>
                <td>${(gene.frequency * 100).toFixed(1)}%</td>
            `;
            tbody.appendChild(row);
        });
        table.appendChild(tbody);
        
        topGenesDiv.appendChild(table);
        
        // Clear and update container
        genesContainer.innerHTML = '';
        genesContainer.appendChild(topGenesDiv);
        
        // Add gene frequency over time chart
        const chartDiv = document.createElement('div');
        chartDiv.innerHTML = '<h5>Gene Frequency Evolution</h5>';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'gene-frequency-chart';
        canvas.width = 280;
        canvas.height = 180;
        chartDiv.appendChild(canvas);
        
        genesContainer.appendChild(chartDiv);
        
        // Draw gene frequency evolution if we have enough data points
        if (dominantGenesData.length > 1) {
            drawGeneFrequencyEvolution('gene-frequency-chart', dominantGenesData);
        } else {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('Not enough data points yet', canvas.width/2, canvas.height/2);
        }
    }
    
    // Function to draw gene frequency evolution
    function drawGeneFrequencyEvolution(canvasId, dominantGenesData) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Get data for top 3 genes currently
        const latestData = dominantGenesData[dominantGenesData.length - 1];
        const topGenes = latestData.dominantGenes.slice(0, 3).map(g => g.sequence);
        
        // Collect frequency data over time for these genes
        const geneData = {};
        topGenes.forEach(gene => {
            geneData[gene] = [];
        });
        
        // Limit to last 10 data points to avoid clutter
        const dataPoints = dominantGenesData.slice(-10);
        
        // Extract timestamps
        const timestamps = dataPoints.map(d => d.timestamp);
        
        // For each timestamp, find frequencies of our top genes
        dataPoints.forEach(point => {
            topGenes.forEach(gene => {
                const found = point.dominantGenes.find(g => g.sequence === gene);
                geneData[gene].push(found ? found.frequency : 0);
            });
        });
        
        // Draw axes
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        ctx.moveTo(30, 20);
        ctx.lineTo(30, canvas.height - 30);
        ctx.lineTo(canvas.width - 20, canvas.height - 30);
        ctx.stroke();
        
        // Y-axis label
        ctx.save();
        ctx.fillStyle = 'white';
        ctx.translate(15, canvas.height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('Frequency', 0, 0);
        ctx.restore();
        
        // X-axis label
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.fillText('Time', canvas.width / 2, canvas.height - 10);
        
        // Draw lines for each gene
        const colors = ['rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 206, 86)'];
        
        Object.entries(geneData).forEach(([gene, frequencies], index) => {
            if (frequencies.length < 2) return;
            
            const color = colors[index % colors.length];
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            // Plot points
            for (let i = 0; i < frequencies.length; i++) {
                const x = 30 + ((canvas.width - 50) / (frequencies.length - 1)) * i;
                const y = (canvas.height - 30) - ((canvas.height - 50) * frequencies[i]);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Legend
            ctx.fillStyle = color;
            ctx.fillRect(canvas.width - 100, 30 + index * 20, 10, 10);
            
            // Truncate gene sequence if too long
            const displayGene = gene.length > 8 ? gene.substring(0, 8) + '...' : gene;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'left';
            ctx.fillText(displayGene, canvas.width - 85, 35 + index * 20);
        });
    }
    
    // Shannon diversity index calculation for species distribution
    function calculateShannonDiversity(distribution) {
        const total = distribution.reduce((sum, count) => sum + count, 0);
        if (total === 0) return 0;
        
        return -distribution.reduce((sum, count) => {
            if (count === 0) return sum;
            const proportion = count / total;
            return sum + (proportion * Math.log(proportion));
        }, 0);
    }
}); 